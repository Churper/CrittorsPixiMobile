<!DOCTYPE html>
<html>


<head>
  <meta charset="utf-8">
  <title>Crittors</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/6.1.3/browser/pixi.min.js"></script>

  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      min-height: 512px;
      height: 100vh;
      user-select: none;
    }

    #game-container {
      position: relative;
      user-select: none;
    }

    #ui-overlay {
      visibility: hidden;
      /* Initially hidden */
      position: fixed;
      bottom: 0;
      left: 55%;
      transform: translateX(-50%);
      user-select: none;
    }

    #pause-text {
      visibility: hidden;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: "Marker Felt", cursive;
      color: black;
      text-shadow: 0px 0px 12px white;
      font-size: 74px;
      user-select: none;
    }

    #pause-button {
      visibility: hidden;
      /* Initially hidden */
      position: fixed;
      top: 10px;
      left: 10px;
      background-image: url("https://i.imgur.com/HTeDEQJ.png");
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      width: 60px;
      height: 60px;
      cursor: pointer;
      user-select: none;
    }

    #coffee-button {
        visibility: hidden;
      font-family: "Marker Felt", cursive;
      font-weight: bold;
      /* Initially hidden */
      position: fixed;
      bottom: 10px;
      left: 10px;
      background-image: url("https://i.imgur.com/Ft63zNi.png");
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      width: 60px;
      height: 60px;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
      /* Prevent text from wrapping */
      text-align: left;
      /* Include padding and border in the width */
      padding-right: 5px;
      /* Add padding to align with the right edge */
    }

    #coffee-amount {
      position: absolute;
      font-size: 36px;
      bottom: 0px;
      left: 65px;
      width: 100%;
      padding: 5px;
      background-color: transparent;
      color: #3a2206;
      text-align: center;
      text-shadow: 1px 1px 2px #000;
      -webkit-text-stroke-width: 0.4px;
      -webkit-text-stroke-color: #fff;
      -webkit-text-fill-color: #3a2206;
    }


    #character-portrait {
      width: 46px;
      height: 46px;
      background-image: url("https://i.imgur.com/yzzwAH6.png");
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      position: absolute;
      left: -44px;
      top: 0px;
      user-select: none;
      filter: sepia(0%);

    }
    .cooldown-overlay {
      display: none;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: 10;
  pointer-events: none;
  animation: cooldown 3s linear;
  animation-fill-mode: forwards;
}

@keyframes cooldown {
  0% {
    width: 100%;
  }
  100% {
    width: 0;
  }
}



    #character-level {
      position: absolute;
      bottom: 46px;
      left: -40px;
      color: rgb(255, 255, 255);
      font-family: "Fredoka One", Arial, sans-serif;
      font-weight: bold;
      text-shadow: 1px 1px .1px rgb(0, 0, 0), 0 0 .1em rgb(0, 0, 255), 0 0 0.1em rgb(255, 0, 0);
      font-size: 12px;
      user-select: none;
    }

    #enemy-portrait {
      width: 46px;
      height: 46px;
      background-image: url("https://i.imgur.com/1EFx7kH.png");
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      position: absolute;
      left: 200px;
      top: 0px;
      filter: grayscale(0%);
      display: none;
      user-select: none;
      /* Hide the element by default */
    }

    #health-bar {
      width: 200px;
      height: 20px;
      background-color: #53282891;
      border: 2px solid #000;
      position: relative;
      user-select: none;
    }

    #health-bar-fill {
      height: 100%;
      background-color: rgba(221, 24, 24, 0.849);
      user-select: none;
    }

    #exp-bar {
      width: 200px;
      height: 20px;
      background-color: #4846a0e1;
      border: 2px solid #000;
      position: relative;
      margin-top: -2px;
      user-select: none;
    }

    #exp-bar-fill {
      height: 100%;
      background-color: #2797d8ec;
      width: 3%;
      /* Set the initial width to 1% */
      user-select: none;
    }







    #character-portrait {
      width: 46px;
      height: 46px;
      background-image: url("https://i.imgur.com/yzzwAH6.png");
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      position: absolute;
      left: -44px;
      top: 0px;
      user-select: none;
      filter: sepia(0%);
      cursor: pointer;
    }

    #character-portrait.active {
      filter: sepia(100%);
    }

    #character-info.active {
      visibility: visible;
    }

    .bar-text {
      font-family: "Marker Felt", cursive;
      position: absolute;
      top: 41%;
      left: 55%;
      transform: translate(-50%, -50%);
      font-weight: bold;
      white-space: nowrap;
      /* Prevent text from wrapping */
      text-align: left;
      /* Align the text to the left */
      width: 100%;
      /* Set the width to 100% */
      box-sizing: border-box;
      /* Include padding and border in the width */
      padding-right: 5px;
      /* Add padding to align with the right edge */
      user-select: none;
    }

    .upgrade-box {
      width: 46px;
      height: 46px;
      position: absolute;
      top: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      background-color: rgba(0, 0, 0, 0.5);
      border: 2px solid #796011c7;
      /* Add a whimsical color for the outline */
      border-radius: 5px;
      /* Increase the border radius for a softer look */
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
      /* Adjust the box shadow for a subtle effect */
      cursor: pointer;
      transition: transform 0.2s ease-in-out;
      visibility: hidden;


    }

    /* Animation for appearing */
    /* Animation for sliding up */
    @keyframes slideUp {
      0% {
        transform: translateY(100%);
      }

      100% {
        transform: translateY(0);
      }
    }

    .upgrade-box.spd-upgrade {
      background-color: rgba(214, 214, 37, 0.719);
      top: -50px;
      left: calc(45% - 70px);
      animation: appear 0.5s ease-in-out forwards, bounce 2s infinite;
      user-select: none;
    }

    .upgrade-box.hp-upgrade {
      background-color: rgba(187, 34, 34, 0.74);
      top: -50px;
      left: calc(45% - 10px);
      /* Reduced spacing */
      animation: appear 0.5s ease-in-out forwards, bounce 2s infinite reverse;
      user-select: none;
    }

    .upgrade-box.attack-upgrade {
      background-color: rgba(20, 110, 39, 0.74);
      top: -50px;
      left: calc(45% + 50px);
      /* Reduced spacing */
      animation: appear 0.5s ease-in-out forwards, bounce 2s infinite;
      user-select: none;
    }


    .upgrade-box.character-snail {
      background-color: rgba(151, 22, 112, 0.753);
      top: -50px;
      left: calc(45% - 70px);
      animation: appear 0.5s ease-in-out forwards, bounce 2s infinite;
      user-select: none;
    }

    .upgrade-box.character-frog {
      background-color: rgba(18, 139, 39, 0.753);
      top: -50px;
      left: calc(45% - 70px);
      animation: appear 0.5s ease-in-out forwards, bounce 2s infinite;
      user-select: none;
    }

    .upgrade-box.character-puffer {
      background-color: rgba(49, 47, 202, 0.801);
      top: -50px;
      left: calc(45% - 10px);
      /* Reduced spacing */
      animation: appear 0.5s ease-in-out forwards, bounce 2s infinite reverse;
      user-select: none;
    }

    .upgrade-box.character-bee {
      background-color: rgba(225, 247, 36, 0.74);
      top: -50px;
      left: calc(45% + 50px);
      /* Reduced spacing */
      animation: appear 0.5s ease-in-out forwards, bounce 2s infinite;
      user-select: none;
    }
    .hp-indicator {
  visibility: inherit;
  position: absolute;
  bottom: 0;
  left: 0;
  width: 10%;
  height: 100%;
  
  background-color: rgba(182, 10, 10, 0.9);
  /* Change the background color to red with opacity 0.5 */
  z-index: 999;
}
.upgrade-box.character-snail .hp-indicator {
  --current-health: var(--current-health-snail);
  --max-health: var(--max-health-snail);
  height: calc(100% - var(--hp-indicator-height));
}

.upgrade-box.character-puffer .hp-indicator {
  --current-health: var(--current-health-puffer);
  --max-health: var(--max-health-puffer);
  height: calc(100% - var(--hp-indicator-height));
}

.upgrade-box.character-bee .hp-indicator {
  --current-health: var(--current-health-bee);
  --max-health: var(--max-health-bee);
  height: calc(100% - var(--hp-indicator-height));
}

.upgrade-box.character-frog .hp-indicator {
  --current-health: var(--current-health-frog);
  --max-health: var(--max-health-frog);
  height: calc(100% - var(--hp-indicator-height));
}



    .upgrade-box:hover {
      animation-play-state: paused;
      transform: scale(1.1);
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5), inset 0 0 10px rgba(0, 0, 0, 0.5);
    }

    .character-icon {
      font-size: 24px;
      color: green;
      /* Change the color to green */
      text-stroke: 2px black;
      /* Add stroke to the text */
      -webkit-text-fill-color: white;
      /* Fallback for older browsers */
      fill: white;
      /* Fill the text color */
      user-select: none;
    }

    #infoboxes {
      visibility: hidden;
      position: fixed;
      left: -80px;
      bottom: 1px;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      margin-bottom: 2px;
      /* Adjust the margin as needed */
      user-select: none;

      color: rgb(255, 255, 255);
      font-family: "Fredoka One", Arial, sans-serif;
      font-weight: bold;
      text-shadow: 1px 1px .1px rgb(0, 0, 0), 0 0 .1em rgb(0, 0, 255), 0 0 0.1em rgb(255, 0, 0);
      font-size: 12px;
      user-select: none;
    }

    .infobox {

      display: flex;
      align-items: center;
      margin-bottom: -2px;
      /* Adjust the margin as needed */
    }

    .upgrade-box {
      margin-top: -4x;
      /* Adjust the margin as needed */
    }

    @keyframes bounce {

      0%,
      100% {
        transform: translateY(0);
      }

      50% {
        transform: translateY(-10px);
      }
    }
  </style>


</head>

<body>
  <div id="game-container">
    <div id="pause-text">paused</div>
    <div id="pause-button" id="coffee-coins"></div>
    <div id="coffee-button"><span id="coffee-amount">x 0</span>
    </div>
    <div id="ui-overlay">

      <div id="infoboxes">
        <div class="infobox">
          <div class="infobox-icon">
            ⚡️
          </div>
          <div class="infobox-level" id="lightning-level">1</div>
        </div>

        <div class="infobox">
          <div class="infobox-icon">
            ❤️
          </div>
          <div class="infobox-level" id="heart-level">100</div>
        </div>

        <div class="infobox">
          <div class="infobox-icon">
            ⚔️
          </div>
          <div class="infobox-level" id="swords-level">20</div>
        </div>

        <div id="character-info" style="display: none;">


        </div>
      </div>


      <div id="character-level">Lvl. 1

      </div>

      <div id="character-portrait">
        <div id="cooldown-overlay" class="cooldown-overlay"></div>
      </div>
      <div id="enemy-portrait"></div>
      <div id="health-bar">
        <div id="health-bar-fill"></div>
        <div class="bar-text" id="hp-text">hp</div>
      </div>
      <div id="exp-bar">
        <div id="exp-bar-fill"></div>
        <div class="bar-text" id="exp-text">exp</div>
      </div>
      <div class="upgrade-box spd-upgrade">
        <div class="upgrade-icon">⚡</div>
      </div>
      <div class="upgrade-box hp-upgrade">
        <div class="upgrade-icon">❤️</div>
      </div>
      <div class="upgrade-box attack-upgrade">
        <div class="upgrade-icon">⚔️</div>
      </div>
      <div class="upgrade-box character-snail">
        <div class="hp-indicator"></div>
        <div class="character-icon">🐌</div>

      </div>

      <div class="upgrade-box character-puffer">
        <div class="hp-indicator"></div>
        <div class="character-icon">🐡</div>

      </div>

      <div class="upgrade-box character-bee">
        <div class="hp-indicator"></div>
        <div class="character-icon">🐝</div>

      </div>

      <div class="upgrade-box character-frog">
        <div class="hp-indicator"></div>
        <div class="character-icon">🐸</div>

      </div>

    </div>
  </div>
  </div>
</body>



<script>
  const app = new PIXI.Application({
    width: window.innerWidth,
    height: Math.max(window.innerHeight),
    antialias: true,
    transparent: false,
    resolution: 1,
  });

  document.body.appendChild(app.view);
let roundOver = false;
  let playerHealth = 100;
  let frogTint = 0;
  let coffee = 0;
  let frogSize = .35;
  let speed = 1.5;
  let speedChanged = false;
  let selectLevel = 0;
  let frogTintColor = 0xffffff;
  let snailSpeed = 1;
  let snailDamage = 20;
  let snailHealth = 100;
  let snailLevel = 1;
  let beeLevel = 1;
  let pufferLevel = 1;
  let pufferSpeed = 1;
  let pufferDamage = 15;
  let pufferHealth = 100;
  let beeSpeed = 1;
  let beeDamage = 25;
  let beeHealth = 100;
  let frogSpeed = 1;
  let frogDamage = 20;
  let frogHealth = 100;
  let frogLevel = 1;
  let currentFrogHealth = 100;
  let currentSnailHealth = 100;
  let currentBeeHealth = 100;
  let currentPufferHealth = 100;
  let charSwap = false;
  let currentCharacter = "character-frog";
  let isCharAttacking = false;
  let playerEXP = 0;
  let isDead = false;
  let enemiesInRange = 0;
  let isCharAttackAnimating = false;
  let areResetting = false;
  let isPaused = false;
  let isAttackingChar = false;
  let isGameStarted = false;

  let expToLevel = 100;
  let cooldownActive = false; // Track the cooldown status
  const cooldownDuration = 3000; // Cooldown duration in milliseconds
  let stored = 0;
  let enemies = [];
  let isCharacterMenuOpen = false; // Flag to track if the character menu is open
  let selectedCharacter = getCurrentCharacter(); // Track the currently selected character
  let previousCharacter = ""; // Track the previously selected character
  const flashDuration = 100; // Adjust as needed (in milliseconds)
  const flashColor = 0xff5555; // Bright red color
  const attackSound = new Audio();
  attackSound.src = "./attacksound.wav";
  const chooseSound = new Audio();
  chooseSound.src = "./upgradeavailable.wav";
  const levelSound = new Audio();
  levelSound.src = "./levelup.wav";
  levelSound.volume = .2;
  const hitSound = new Audio();
  hitSound.src = "./hurt.wav";
  let isCombat = false;
  let playAgain = false;
  let isPointerDown = false;
  const menuTexture = PIXI.Texture.from('https://i.imgur.com/YtBjxdf.png');
  const menuSprite = new PIXI.Sprite(menuTexture);
  let characterPositions = {
    "character-snail": {
      top: "-50px",
      left: "calc(45% - 70px)"
    },
    "character-frog": {
      top: "-50px",
      left: "calc(45% - 70px)"
    },
    "character-puffer": {
      top: "-50px",
      left: "calc(45% - 10px)"
    },
    "character-bee": {
      top: "-50px",
      left: "calc(45% + 50px)"
    }
  };


  function getRoundOver() {
    return roundOver;
  }
  function setRoundOver(bool) {
    roundOver = bool;
  }
  function getCurrentFrogHealth() {
    return currentFrogHealth;
  }
  function setCurrentFrogHealth(health) {
    currentFrogHealth = health;
    const frogHpIndicator = document.querySelector('.upgrade-box.character-frog .hp-indicator');
    frogHpIndicator.style.setProperty('--hp-indicator-height', `${(1 - (getCurrentFrogHealth() / getFrogHealth())) * 100}%`);
  }

  function setCurrentBeeHealth(health) {
    currentBeeHealth = health;
    const beeHpIndicator = document.querySelector('.upgrade-box.character-bee .hp-indicator');
    beeHpIndicator.style.setProperty('--hp-indicator-height', `${(1 - (getCurrentBeeHealth() / getBeeHealth())) * 100}%`);
  }

  function setCurrentSnailHealth(health) {
    currentSnailHealth = health;
    const snailHpIndicator = document.querySelector('.upgrade-box.character-snail .hp-indicator');
    snailHpIndicator.style.setProperty('--hp-indicator-height', `${(1 - (getCurrentSnailHealth() / getSnailHealth())) * 100}%`);
  }

  function setCurrentPufferHealth(health) {
    currentPufferHealth = health;
    const pufferHpIndicator = document.querySelector('.upgrade-box.character-puffer .hp-indicator');
    pufferHpIndicator.style.setProperty('--hp-indicator-height', `${(1 - (getCurrentPufferHealth() / getPufferHealth())) * 100}%`);
  }

  function getCurrentBeeHealth() {
    return currentBeeHealth;
  }

  function getCurrentSnailHealth() {
    return currentSnailHealth;
  }

  function getCurrentPufferHealth() {
    return currentPufferHealth;
  }

  function setSnailLevel(level) {
    snailLevel = level;
  }

  function getSnailLevel() {
    return snailLevel;
  }

  function setBeeLevel(level) {
    beeLevel = level;
  }

  function getBeeLevel() {
    return beeLevel;
  }

  function setPufferLevel(level) {
    pufferLevel = level;
  }

  function getPufferLevel() {
    return pufferLevel;
  }


  function getSnailSpeed() {
    return snailSpeed;
  }

  function setSnailSpeed(speed) {
    snailSpeed = speed;
  }

  function getSnailDamage() {
    return snailDamage;
  }

  function setSnailDamage(damage) {
    snailDamage = damage;
  }


  function getFrogLevel() {
    return frogLevel;
  }

  function setFrogLevel(level) {
    frogLevel = level;
  }

  function getSnailHealth() {
    return snailHealth;
  }

  function setSnailHealth(health) {
    snailHealth = health;
  }


  function getPufferSpeed() {
    return pufferSpeed;
  }

  function setPufferSpeed(speed) {
    pufferSpeed = speed;
  }

  function getPufferDamage() {
    return pufferDamage;
  }

  function setPufferDamage(damage) {
    pufferDamage = damage;
  }

  function getPufferHealth() {
    return pufferHealth;
  }

  function setPufferHealth(health) {
    pufferHealth = health;
  }



  function getBeeSpeed() {
    return beeSpeed;
  }

  function setBeeSpeed(speed) {
    beeSpeed = speed;
  }

  function getBeeDamage() {
    return beeDamage;
  }

  function setBeeDamage(damage) {
    beeDamage = damage;
  }

  function getBeeHealth() {
    return beeHealth;
  }

  function setBeeHealth(health) {
    beeHealth = health;
  }

  function getFrogSpeed() {
    return frogSpeed;
  }

  function setFrogSpeed(speed) {
    frogSpeed = speed;
  }

  function getFrogDamage() {
    return frogDamage;
  }

  function setFrogDamage(damage) {
    frogDamage = damage;
  }

  function getFrogHealth() {
    return frogHealth;
  }



  function getEnemies() {
    return enemies;
  }

  function addEnemies(enemy) {
    console.log("added an eneymy");
    return enemies.push(enemy);
  }

  function clearEnemies(value) {
    enemies = [];
  }


  function setFrogHealth(health) {
    frogHealth = health;
  }


  var snailHPIndicator = document.querySelector('.upgrade-box.character-snail .hp-indicator');
  var pufferHPIndicator = document.querySelector('.upgrade-box.character-puffer .hp-indicator');
  var beeHPIndicator = document.querySelector('.upgrade-box.character-bee .hp-indicator');
  var frogHPIndicator = document.querySelector('.upgrade-box.character-frog .hp-indicator');

  // Calculate the height percentage for each character
  var snailHeightPercentage = (1 - getCurrentSnailHealth() / getSnailHealth()) * 100;
  var pufferHeightPercentage = (1 - getCurrentPufferHealth() / getPufferHealth()) * 100;
  var beeHeightPercentage = (1 - getCurrentBeeHealth() / getBeeHealth()) * 100;
  var frogHeightPercentage = (1 - getCurrentFrogHealth() / getFrogHealth()) * 100;

  // Update the custom properties and height for each character
  snailHPIndicator.style.setProperty('--current-health-snail', getCurrentSnailHealth());
  snailHPIndicator.style.setProperty('--max-health-snail', getSnailHealth());
  snailHPIndicator.style.setProperty('--hp-indicator-height', snailHeightPercentage + '%');

  pufferHPIndicator.style.setProperty('--current-health-puffer', getCurrentPufferHealth());
  pufferHPIndicator.style.setProperty('--max-health-puffer', getPufferHealth());
  pufferHPIndicator.style.setProperty('--hp-indicator-height', pufferHeightPercentage + '%');

  beeHPIndicator.style.setProperty('--current-health-bee', getCurrentBeeHealth());
  beeHPIndicator.style.setProperty('--max-health-bee', getBeeHealth());
  beeHPIndicator.style.setProperty('--hp-indicator-height', beeHeightPercentage + '%');

  frogHPIndicator.style.setProperty('--current-health-frog', getCurrentFrogHealth());
  frogHPIndicator.style.setProperty('--max-health-frog', getFrogHealth());
  frogHPIndicator.style.setProperty('--hp-indicator-height', frogHeightPercentage + '%');

  function getCharSwap() {
    return charSwap;
  }

  function setCharSwap(value) {
    charSwap = value;
  }

  function getCurrentCharacter() {
    return currentCharacter;
  }

  function setCurrentCharacter(value) {
    currentCharacter = value;
  }

  function getFrogTint() {
    return frogTint;
  }

  function setFrogTint(value) {
    frogTint = value;
  }


  function getCoffee() {
    return coffee;
  }

  function setCoffee(value) {
    coffee = value;
  }



  function getFrogSize() {
    return frogSize;
  }

  function setFrogSize(value) {
    frogSize = value;
  }



  function getFrogSpeed() {
    return speed;
  }

  function setFrogSpeed(value) {
    speed = value;
  }



  function getSpeedChanged() {
    return speedChanged;
  }

  function setSpeedChanged(value) {
    speedChanged = value;
  }



  function getSelectLevel() {
    return selectLevel;
  }

  function setSelectLevel(value) {
    selectLevel = value;
  }




  function getFrogTintColor() {
    return frogTintColor;
  }

  function setFrogTintColor(value) {
    frogTintColor = value;
  }


  function getSpeed() {
    return speed;
  }

  function setSpeed(value) {
    speed = value;
  }



  function getPlayerHealth() {


    switch (getCurrentCharacter()) {
      case 'character-snail':
        return getSnailHealth();
        break;
      case 'character-puffer':
        return getPufferHealth();
        break;
      case 'character-frog':
        return getFrogHealth();
        break;
      case 'character-bee':
        return getBeeHealth();
        break;
      default:
        console.log('Invalid character type');
    }


    return playerHealth;
  }




  function getPlayerCurrentHealth() {


    switch (getCurrentCharacter()) {
      case 'character-snail':
        return getCurrentSnailHealth();
        break;
      case 'character-puffer':
        return getCurrentPufferHealth();
        break;
      case 'character-frog':
        return getCurrentFrogHealth();
        break;
      case 'character-bee':
        return getCurrentBeeHealth();
        break;
      default:
        console.log('Invalid character type');
    }


    return playerHealth;
  }


  function setPlayerHealth(value) {
    switch (getCurrentCharacter()) {
      case 'character-snail':
        setSnailHealth(value);
        break;
      case 'character-puffer':
        setPufferHealth(value);
        break;
      case 'character-frog':
        setFrogHealth(value);
        break;
      case 'character-bee':
        setBeeHealth(value);
        break;
      default:
        console.log('Invalid character type');
    }
  }

  function setPlayerCurrentHealth(value) {
    switch (getCurrentCharacter()) {
      case 'character-snail':
        setCurrentSnailHealth(value);
        break;
      case 'character-puffer':
        setCurrentPufferHealth(value);
        break;
      case 'character-frog':
        setCurrentFrogHealth(value);
        break;
      case 'character-bee':
        setCurrentBeeHealth(value);
        break;
      default:
        console.log('Invalid character type');
    }
  }


  function getPlayerEXP() {
    return playerEXP;
  }
  function setPlayerEXP(value) {
    playerEXP = value;
  }

  function getisDead() {
    return isDead;
  }

  function setIsDead(value) {
    isDead = value;
  }


  function getIsCharAttacking() {
    return isCharAttacking;
  }

  function setIsCharAttacking(value) {
    isCharAttacking = value;
  }

  function getAreResetting() {
    return areResetting;
  }

  function setAreResetting(value) {
    areResetting = value;
  }


  function getIsCharAttackAnimating() {
    return isCharAttackAnimating;
  }

  function setCharAttackAnimating(value) {
    isCharAttackAnimating = value;
  }


  function getEnemiesInRange() {
    return enemiesInRange;
  }

  function setEnemiesInRange(value) {
    enemiesInRange = value;
  }



  function getisPaused() {
    return isPaused;
  }

  function setisPaused(value) {
    isPaused = value;

    // Get the pause text element
    var pauseText = document.getElementById("pause-text");

    // Swap the visibility based on the isPaused value
    if (isPaused) {
      pauseText.style.visibility = "visible";
    } else {
      pauseText.style.visibility = "hidden";
    }

  }


  function isCooldownActive() {
    return cooldownActive;
  }

  function startCooldown() {
    cooldownActive = true;

    // Show the cooldown overlay
    const overlayElement = document.getElementById("cooldown-overlay");
    overlayElement.style.display = "block";

    setTimeout(() => {
      cooldownActive = false;

      // Hide the cooldown overlay
      overlayElement.style.display = "none";
    }, cooldownDuration);
  }




  document.getElementById("character-portrait").addEventListener("click", function () {
    if (getSelectLevel() >= 1) {
      return;
    }

    // Check if there is a cooldown
    if (isCooldownActive()) {
      return;
    }

    // Toggle the visibility of the character info boxes
    const characterBoxes = document.querySelectorAll('.upgrade-box.character-snail, .upgrade-box.character-puffer, .upgrade-box.character-bee, .upgrade-box.character-frog');

    if (isCharacterMenuOpen) {
      characterBoxes.forEach((box) => {
        box.style.visibility = 'hidden';
      });
      isCharacterMenuOpen = false;
    } else {
      characterBoxes.forEach((box) => {
        if (selectedCharacter !== "" && box.classList.contains(selectedCharacter)) {
          box.style.visibility = 'hidden';
        } else {
          box.style.visibility = 'visible';
        }
      });
      isCharacterMenuOpen = true;
    }

    // Start the cooldown

  });

  function handleCharacterClick(characterType) {
    // Swap character portraits
    const characterPortrait = document.getElementById("character-portrait");
    characterPortrait.style.backgroundImage = `url('${getCharacterPortraitUrl(characterType)}')`;
    characterPortrait.classList.remove("character-snail", "character-puffer", "character-bee", "character-frog");
    characterPortrait.classList.add(characterType);


    // Close the character menu
    const characterBoxes = document.querySelectorAll('.upgrade-box.character-snail, .upgrade-box.character-puffer, .upgrade-box.character-bee, .upgrade-box.character-frog');
    characterBoxes.forEach((box) => {
      box.style.visibility = 'hidden';
    });
    isCharacterMenuOpen = false;
    setCharSwap(true);

    setCurrentCharacter(characterType);

    // Swap positions of the current character box and the previously selected character box
    if (selectedCharacter !== characterType) {
      const characterLevelElement = document.getElementById("character-level");
      var updateLightning = document.getElementById("lightning-level");
      var updateHP = document.getElementById("heart-level");
      var updateDamage = document.getElementById("swords-level");


      let level;

      switch (characterType) {
        case 'character-snail':
          level = getSnailLevel();

          updateLightning.textContent = getSnailSpeed().toString();
          updateHP.textContent = getSnailHealth().toString();
          updateDamage.textContent = getSnailDamage().toString();
          break;
        case 'character-puffer':
          level = getPufferLevel();
          updateLightning.textContent = getPufferSpeed().toString();
          updateHP.textContent = getPufferHealth().toString();
          updateDamage.textContent = getPufferDamage().toString();

          break;
        case 'character-frog':
          level = getFrogLevel();
          updateLightning.textContent = getFrogSpeed().toString();
          updateHP.textContent = getFrogHealth().toString();
          updateDamage.textContent = getFrogDamage().toString();
          break;
        case 'character-bee':
          level = getBeeLevel();
          updateLightning.textContent = getBeeSpeed().toString();
          updateHP.textContent = getBeeHealth().toString();
          updateDamage.textContent = getBeeDamage().toString();
          break;
        default:
          console.log('Invalid character', characterType);
          return;
      }
      startCooldown();
      updatePlayerHealthBar((getPlayerCurrentHealth() / getPlayerHealth() * 100));
      characterLevelElement.textContent = 'Lvl. ' + level;

      const currentCharacterBox = document.querySelector('.upgrade-box.' + selectedCharacter);
      const prevCharacterBox = document.querySelector('.upgrade-box.' + characterType);
      const tempPosition = { ...characterPositions[selectedCharacter] };

      currentCharacterBox.style.top = characterPositions[characterType].top;
      currentCharacterBox.style.left = characterPositions[characterType].left;
      characterPositions[selectedCharacter] = characterPositions[characterType];
      characterPositions[characterType] = tempPosition;

      previousCharacter = selectedCharacter;
      selectedCharacter = characterType;
    } else {
      previousCharacter = ""; // Set previousCharacter to an empty string if the same character is selected again
    }

    updateCharacterStats(); // Update the stats for the new character
  }




  function updateCharacterStats() {
    switch (selectedCharacter) {
      case 'character-snail':
        // Update stats for character-snail
        setSnailSpeed(getSnailSpeed());
        setSnailDamage(getSnailDamage());
        setSnailHealth(getSnailHealth());
        // Additional logic or actions specific to character-snail
        break;
      case 'character-puffer':
        // Update stats for character-puffer
        setPufferSpeed(getPufferSpeed());
        setPufferDamage(getPufferDamage());
        setPufferHealth(getPufferHealth());
        // Additional logic or actions specific to character-puffer
        break;
      case 'character-frog':
        // Update stats for character-frog
        setFrogSpeed(getFrogSpeed());
        setFrogDamage(getFrogDamage());
        setFrogHealth(getFrogHealth());
        // Additional logic or actions specific to character-frog
        break;
      case 'character-bee':
        // Update stats for character-bee
        setBeeSpeed(getBeeSpeed());
        setBeeDamage(getBeeDamage());
        setBeeHealth(getBeeHealth());
        // Additional logic or actions specific to character-bee
        break;
      default:
        console.log('Invalid character type', selectedCharacter);
    }

    // Update the display or perform any other actions based on the updated stats
    // ...
  }




  // Add click event listeners to character boxes
  const characterBoxes = document.querySelectorAll('.upgrade-box.character-snail, .upgrade-box.character-puffer, .upgrade-box.character-bee, .upgrade-box.character-frog');
  characterBoxes.forEach((box) => {
    box.addEventListener('click', function () {
      const characterType = box.classList[1];
      handleCharacterClick(characterType);

    });
  });


  function getCharacterPortraitUrl(characterType) {
    switch (characterType) {
      case 'character-snail':
        return 'https://i.imgur.com/Chu3ZkP.png';
      case 'character-puffer':
        return 'https://i.imgur.com/9gLYMax.png';
      case 'character-frog':
        return 'https://i.imgur.com/XaXTV73.png';
      case 'character-bee':
        return 'https://i.imgur.com/rmcGGP9.png';
      default:
        return '';
    }
  }


  document.addEventListener("DOMContentLoaded", function () {
    var pauseButton = document.getElementById("pause-button");

    document.addEventListener("contextmenu", function (event) {
      event.preventDefault();
    });

    pauseButton.addEventListener("click", function () {
      setisPaused(!getisPaused());
      console.log("PAUSED");
    });
  });

  document.addEventListener("DOMContentLoaded", function () {
    var pauseButton = document.getElementById("pause-button");

    pauseButton.addEventListener("mousedown", function () {
      pauseButton.style.backgroundImage = 'url("https://i.imgur.com/gGcCLKj.png")';
      console.log("Button Pressed");
    });

    pauseButton.addEventListener("mouseup", function () {
      pauseButton.style.backgroundImage = 'url("https://i.imgur.com/HTeDEQJ.png")';
      console.log("Button Released");
    });
  });

  menuSprite.anchor.set(0.5);
  menuSprite.width = app.screen.width;
  menuSprite.height = app.screen.height - 26;
  menuSprite.position.set(app.screen.width / 2, app.screen.height / 2);
  app.stage.addChild(menuSprite);
  document.body.appendChild(app.view);
  const playButtonTexture = PIXI.Texture.from('https://i.imgur.com/5zdfKQG.png');
  const playButton = new PIXI.Sprite(playButtonTexture);
  playButton.anchor.set(.5, .5);
  playButton.interactive = true;
  playButton.buttonMode = true;
  playButton.position.set(app.screen.width / 8, app.screen.height / 5);
  const hoverScale = 1.2;
const hoverAlpha = 0.8;
  app.stage.addChild(playButton);

  function getisPointerdown() {
    return isPointerDown;
  }

  function startGame() {

    window.addEventListener('blur', () => {

      setisPaused(true);
    });

    const loadingTexture = PIXI.Texture.from('https://i.imgur.com/dJ4eoGZ.png');
    const loadingSprite = new PIXI.Sprite(loadingTexture);
    loadingSprite.anchor.set(0.5);
    loadingSprite.width = app.screen.width;
    loadingSprite.height = app.screen.height;
    loadingSprite.position.set(app.screen.width / 2, app.screen.height / 2);


    loadingSprite.alpha = 1; // Start fully opaque

    app.stage.removeChild(menuSprite);
    app.stage.removeChild(playButton);
    app.stage.addChild(loadingSprite);

    const sound = new Audio();
    sound.src = "./theme.ogg";
    sound.volume = .02;
    sound.play();

    // Game elements and logic 
    const castleMaxHealth = 100;
    let castleHealth = castleMaxHealth;
    const LEFT_ARROW_KEYCODE = 37;
    const RIGHT_ARROW_KEYCODE = 39;
    const UP_ARROW_KEYCODE = 38;
    const SPACEBAR_KEYCODE = 32;
    const DOWN_ARROW_KEYCODE = 40;

    const mountainVelocityX = 0;
    const mountainVelocityY = 0.2;
    const mountainVelocity1 = new PIXI.Point(0.2, 0.2);
    const mountainVelocity2 = new PIXI.Point(0.05, 0.05);
    let keysPressed = 0;
    const hpBarColor = 0xff0000;






    PIXI.Loader.shared.add([
      { name: 'frog_snail', url: 'https://i.imgur.com/ekpSpFg.png' },
      { name: 'frog_bee', url: 'https://i.imgur.com/bUw6K0K.png' },
      { name: 'frog_puffer', url: 'https://i.imgur.com/fBWKqfA.png' },
      { name: 'bee_walk', url: 'https://i.imgur.com/Jxke4OH.png' },
      { name: 'bee_attack', url: 'https://i.imgur.com/toZiN31.png' },
      { name: 'puffer_walk', url: 'https://i.imgur.com/bPKkQzn.png' },
      { name: 'puffer_attack', url: 'https://i.imgur.com/j54CxV4.png' },
      { name: 'puffer_portrait', url: 'https://i.imgur.com/9gLYMax.png' },
      { name: 'snail_portrait', url: 'https://i.imgur.com/Chu3ZkP.png' },
      { name: 'frog_portrait', url: 'https://i.imgur.com/XaXTV73.png' },
      { name: 'bee_portrait', url: 'https://i.imgur.com/rmcGGP9.png' },
      { name: 'bean', url: 'https://i.imgur.com/Ft63zNi.png ' },
      { name: 'background', url: 'https://i.imgur.com/HNTGehL.png' },
      { name: 'frog_ghost', url: 'https://i.imgur.com/45E9OPW.png' },
      { name: 'foreground', url: 'https://i.imgur.com/yIjGEpm.png' },
      { name: 'critter', url: 'https://i.imgur.com/Fl29VZM.png' },
      { name: 'critter_walk', url: 'https://i.imgur.com/CLqwc9P.png' },
      { name: 'critter_attack', url: 'https://i.imgur.com/knXBNGy.png' },
      { name: 'snail_idle', url: 'https://i.imgur.com/ctlOf0I.png' },
      { name: 'snail_walk', url: 'https://i.imgur.com/TQzhxAI.png' },
      { name: 'snail_attack', url: 'https://i.imgur.com/2cGPPic.png' },
      { name: 'frog', url: 'https://i.imgur.com/juol8Q6.png' },
      { name: 'frog_walk', url: 'https://i.imgur.com/sQDZVrY.png' },
      { name: 'frog_attack', url: 'https://i.imgur.com/2Nr5t05.png' },
      { name: 'enemy_death', url: 'https://i.imgur.com/UD2YJ4w.png' },
      { name: 'mountain1', url: 'https://i.imgur.com/FP1W0k6.png' },
      { name: 'mountain2', url: 'https://i.imgur.com/Y6IKYjW.png' },
      { name: 'castle', url: 'https://i.imgur.com/a8MEgLK.png' },
      { name: 'clouds', url: 'https://i.imgur.com/ggEcYj9.png' }
    ]).load(setup);


    function setup() {

      const backgroundTexture = PIXI.Loader.shared.resources['background'].texture;
      const background = new PIXI.Sprite(backgroundTexture);
      background.width = app.screen.width * 2.75;
      background.height = app.screen.height;
      background.anchor.set(0.5, 0);
      background.position.set(0, 0);

      const anotherBackground = new PIXI.Sprite(backgroundTexture);
      anotherBackground.width = app.screen.width * 2.75;
      anotherBackground.height = app.screen.height;
      anotherBackground.anchor.set(0.5, 0);
      anotherBackground.position.set(app.screen.width * 2.75, 0);

      app.stage.addChild(background);
      app.stage.addChild(anotherBackground);


      const characterPortraitTexture = PIXI.Texture.from('https://i.imgur.com/8y7Ehfw.png');
      const characterPortrait = new PIXI.Sprite(characterPortraitTexture);
      const frogGhost = PIXI.Texture.from('frog_ghost');

      const frogGhostTextures = PIXI.Loader.shared.resources['frog_ghost'].texture;
      const frogGhostPlayer = new PIXI.Sprite(frogGhostTextures);

      frogGhostPlayer.anchor.set(0, 0);
      frogGhostPlayer.scale.set(0.28);


      const containerHeight = document.getElementById('game-container').clientHeight;
      const containerWidth = document.getElementById('game-container').clientWidth;
      const foreground = new PIXI.Sprite(PIXI.Loader.shared.resources['foreground'].texture);
      foreground.width = PIXI.Loader.shared.resources['foreground'].texture.width;
      foreground.height = PIXI.Loader.shared.resources['foreground'].texture.height;
      foreground.anchor.set(0, 1);
      foreground.x = 0;

      foreground.y = Math.max(app.screen.height);
      const mountain1 = createMountainSprite('mountain1', -100, mountainVelocity1, foreground);
      const mountain2 = createMountainSprite('mountain2', app.screen.width * 0.35, mountainVelocity2, foreground); // Adjust the position as needed
      foreground.x = 0;

      const castleTexture = PIXI.Texture.from('castle');
      const castle = new PIXI.Sprite(castleTexture);
      castle.anchor.set(1, 1);
      castle.position.set(foreground.width - castle.width * 0.05, app.screen.height - castle.height * 0.15);

      const hpBarWidth = 180;
      const hpBarHeight = 16;

      const hpBarX = castle.position.x - castle.width / 1.1;
      // console.log(hpBarX);
      const hpBarY = app.screen.height - 40 - hpBarHeight - 210; // Adjusted position
      const hpBarBackgroundColor = 0x000000;
      const hpBar = new PIXI.Graphics();
      hpBar.beginFill(hpBarColor, 1); // Set the alpha value for transparency
      hpBar.drawRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);
      hpBar.endFill();
      const hpBarBackground = new PIXI.Graphics();
      const hpBarBorderColor = 0x000000; // Black color
      const hpBarBorderThickness = 4;
      hpBarBackground.lineStyle(hpBarBorderThickness, hpBarBorderColor);
      hpBarBackground.beginFill(hpBarBackgroundColor, 0.5);
      hpBarBackground.drawRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);
      hpBarBackground.endFill();
      hpBarBackground.beginFill(hpBarBackgroundColor, 1);
      hpBarBackground.drawRect(hpBarX + hpBarBorderThickness, hpBarY + hpBarBorderThickness, hpBarWidth - hpBarBorderThickness * 2, hpBarHeight - hpBarBorderThickness * 2);
      hpBarBackground.endFill();
      function createMountainSprite(resourceName, xPos, velocity, foreground) {
        const sprite = new PIXI.Sprite(PIXI.Loader.shared.resources[resourceName].texture);

        const scaleFactor = Math.min(
          app.screen.height * 0.6 / sprite.height,
          app.screen.width * 1.5 / sprite.width
        );

        sprite.scale.set(scaleFactor);
        sprite.anchor.set(0, 1);

        const minHeightOffset = foreground ? foreground.height * 0.34 : 0;
        const heightOffsetRatio = (1 - scaleFactor) * 0.3; // Adjust this ratio based on your preference

        const foregroundHeightOffset = foreground ? minHeightOffset + sprite.height * heightOffsetRatio : 0; // Adjusted offset calculation
        sprite.position.set(xPos, app.screen.height - foregroundHeightOffset);
        sprite.zIndex = -1;
        sprite.velocity = velocity;

        return sprite;
      }



      let frogIdleTexture = PIXI.Loader.shared.resources['frog'].texture;
      let frogIdleTextures = [frogIdleTexture];
      const frogIdleTexture1 = PIXI.Loader.shared.resources['frog'].texture;
      const frogIdleTextures1 = [frogIdleTexture];
      let frogWalkTextures = createAnimationTextures('frog_walk', 10, 351);
      let frogAttackTextures = createAnimationTextures('frog_attack', 12, 351);
      const frogWalkTextures1 = createAnimationTextures('frog_walk', 10, 351);
      const frogAttackTextures1 = createAnimationTextures('frog_attack', 12, 351);
      const critterAttackTextures = createAnimationTextures('critter_attack', 13, 266);
      const critterIdleTexture = PIXI.Loader.shared.resources['critter'].texture;
      const critterWalkTextures = createAnimationTextures('critter_walk', 12, 266);
      const snailIdleTextures = createAnimationTextures2('snail_idle', 20, 562, 3560, 2248);
      const snailWalkTextures = createAnimationTextures2('snail_walk', 20, 562, 3560, 2248);
      const snailAttackTextures = createAnimationTextures2('snail_attack', 20, 562, 2848, 3372);
      const pufferWalkTextures = createAnimationTextures2('puffer_walk', 15, 413, 3705, 1239);
      const pufferAttackTextures = createAnimationTextures2('puffer_attack', 21, 413, 2223, 2891);
      const beeWalkTextures = createAnimationTextures2('bee_walk', 9, 256, 2753, 256);
      const beeAttackTextures = createAnimationTextures2('bee_attack', 18, 256, 1950, 1024);
      const cloudsTexture = PIXI.Loader.shared.resources['clouds'].texture;
      const backgroundImage = PIXI.Sprite.from('background');
      const clouds = createTilingSprite(cloudsTexture, backgroundImage.width * 3, 200);
      const enemyDeathTextures = createAnimationTextures('enemy_death', 8, 317);
      const enemyDeath = createAnimatedSprite(enemyDeathTextures);
      const playerSpawn = createAnimatedSprite(enemyDeathTextures);

      let characterTextures;
      // const frogWalkTextures = 
      // const frogWalkTextures = 
      characterTextures = frogWalkTextures;

      const critter = createAnimatedSprite(characterTextures);
      critter.interactive = true;

      critter.textures = frogWalkTextures;
      critter.loop = true;
      critter.play();
// Define the desired color in hexadecimal format
const desiredColor = 0x00ff00; // Green color

// Apply the color filter to the sprite
playerSpawn.tint = desiredColor;
      playerSpawn.animationSpeed = 0.175;
      playerSpawn.loop = false;
      playerSpawn.anchor.set(.65, 0.2);
      playerSpawn.scale.set(0.35);

      enemyDeath.animationSpeed = 0.175;
      enemyDeath.loop = false;
      enemyDeath.anchor.set(0.2, 0);
      enemyDeath.scale.set(0.35);

      const velocity = new PIXI.Point();
      const parallaxRatio = 0.5;

      const pressedKeys = new Set();
      let xDir = 0;
      let yDir = 0;
      let isMoving = false;


      function createAnimationTextures(resourceName, frameCount, frameHeight) {
        const textures = [];
        const textureWidth = PIXI.Loader.shared.resources[resourceName].texture.width / frameCount;

        for (let i = 0; i < frameCount; i++) {
          const rect = new PIXI.Rectangle(i * textureWidth, 0, textureWidth, frameHeight);
          const texture = new PIXI.Texture(PIXI.Loader.shared.resources[resourceName].texture, rect);
          textures.push(texture);
        }

        return textures;
      }

      function createAnimationTextures2(resourceName, frameCount, frameHeight, sheetWidth, sheetHeight) {
        const textures = [];
        const frameWidth = sheetWidth / Math.ceil(frameCount / (sheetHeight / frameHeight));

        for (let i = 0; i < frameCount; i++) {
          const row = Math.floor(i / (sheetWidth / frameWidth));
          const col = i % (sheetWidth / frameWidth);
          const rect = new PIXI.Rectangle(col * frameWidth, row * frameHeight, frameWidth, frameHeight);
          const texture = new PIXI.Texture(PIXI.Loader.shared.resources[resourceName].texture, rect);
          textures.push(texture);
        }

        return textures;
      }




      function createAnimatedSprite(textures) {
        const sprite = new PIXI.AnimatedSprite(textures);
        sprite.scale.set(0.5);
        sprite.anchor.set(.5, .5);
        sprite.position.set(app.screen.width / 3, app.screen.height - foreground.height / 1.6);
        sprite.animationSpeed = 0.25;
        sprite.zIndex = 1;
        sprite.loop = true;
        return sprite;
      }

      function createTilingSprite(texture, width, height) {
        const sprite = new PIXI.TilingSprite(texture, width, height);
        sprite.tileScale.set(0.4);
        sprite.tilePosition.y = 200;
        app.stage.addChild(sprite);
        return sprite;
      }

      // Constants
      const SPACEBAR_KEYCODE = 32;
      // Variables
      let attackAnimationPlayed = false; // Flag variable to track if attack animation has played
      let pointerHoldInterval;
      app.stage.interactive = true;
      app.stage.on("pointerdown", handleTouchStart);
      app.stage.on("pointerup", handleTouchEnd);
      xDir = 1;
      updateVelocity();
      critter.loop = true;


      function handleTouchStart(event) {
        if (attackAnimationPlayed) { attackAnimationPlayed = false; }

        if (getisPaused()) {
          setisPaused(false);
          return;
        }

        function handleMouseLeave(event) {
          isPointerDown = false;
          console.log('Mouse has left the screen');
          attackAnimationPlayed = true;
          handleTouchEnd(event);

          // Perform any additional actions you want here
        }

        function handleTouchHold() {

          if (getisPaused()) {
            return;
          }

          if (!isAttackingChar) {
            if (!getisDead()) {

              isAttackingChar = true;
              critter.textures = frogAttackTextures;
              setCharAttackAnimating(true);
              critter.loop = false;
              critter.onComplete = function () {

                if (!isAttackingChar) {
                  return; // Return early if attack was interrupted (paused)
                }
                if (isAttackingChar) {
                  attackAnimationPlayed = true;
                  attackSound.volume = .1;
                  attackSound.src = "./attacksound.wav";
                  attackSound.play();

                  if (critter.position.x > castle.position.x - castle.width / 1.1) {
                    console.log("takingDamage");
                    castleTakeDamage(10); // Damage calculation
                  }
                  isAttackingChar = false;
                  isMoving = false;

                }
                // isAttackingChar = false;

                critter.play();
              };
              critter.play();

            }

          }

        }

        isPointerDown = true;
        pointerHoldInterval = setInterval(handleTouchHold, 10);

        // Add an event listener to check if the mouse leaves the document
        document.addEventListener("mouseout", handleMouseLeave);

        // Remove the event listener when touch ends
        document.addEventListener("touchend", function () {
          clearInterval(pointerHoldInterval);
          document.removeEventListener("mouseout", handleMouseLeave);

        });
      }

      // Function to handle pointerup event
      function handleTouchEnd(event) {

        // console.log("ping");
        clearInterval(pointerHoldInterval);
        isPointerDown = false;



        if (!attackAnimationPlayed) {
          return;
        } else {
          attackAnimationPlayed = true;

          return;

          // Reset the textures and start the animation again
          critter.textures = frogAttackTextures;
          critter.loop = false;
          critter.play();
        }






        xDir = 1;
      }

      function resetCharacter() {

        isAttackingChar = false;
        isMoving = false;



      }



      function updateVelocity() {

        setIsCharAttacking(false);
        velocity.x = xDir * getFrogSpeed();
        velocity.y = yDir * getFrogSpeed();
        // console.log(isMoving);
        if (isMoving) {
          mountainVelocity1.x = mountainVelocityX;
          mountainVelocity1.y = mountainVelocityY;
          mountainVelocity2.x = mountainVelocityX;
          mountainVelocity2.y = mountainVelocityY;

        }

      }

      // Function to update the HP bar based on the castle's health
      function updateHPBar(health, maxHealth) {

        const hpRatio = health / maxHealth;
        const newHpWidth = Math.max(0, hpBarWidth * hpRatio);
        hpBar.clear();
        hpBar.beginFill(hpBarColor);
        hpBar.drawRect(hpBarX, hpBarY, newHpWidth, hpBarHeight);
        hpBar.endFill();
      }


      // Damage function
      function castleTakeDamage(damage) {
        castleHealth -= damage;
        if (castleHealth < 0) {
          castleHealth = 0;
          castleExplode();
        }
        updateHPBar(castleHealth, castleMaxHealth);
      }

      function castleExplode() {
setRoundOver(true);
      }

      let unPauser = 0;
      const maxX = foreground.width - critter.width / 2;
      const minX = critter.width / 2;
      const maxY = app.screen.height * 0.85;
      const minY = app.screen.height * 0.5;
      const cloudSpeed = 1 / 3.5;
      const mountain1Speed = 0.2;
      const mountain2Speed = 0.05;
      app.ticker.add(() => {


        if (getisPaused()) {

          // Game is paused, skip logic
          critter.stop();

          getEnemies().forEach(enemy => {
            enemy.stop();
          });
          unPauser = 1;
          return;
        }
        if (unPauser === 1) {
          critter.play();
          getEnemies().forEach(enemy => {
            enemy.play();
          });
          unPauser = 0;
          return;
        }
        //console.log("isatt:", isAttackingChar);
if(getRoundOver()){
// Calculate the amount to move the camera per frame
const cameraSpeed = 3;

// Calculate the target position (start position)
const targetX = 0;
const targetY = 0;

// Calculate the distance between the current position and the target position
const distanceX = targetX - app.stage.x;
const distanceY = targetY - app.stage.y;

// Calculate the movement for this frame
const movementX = Math.sign(distanceX) * Math.min(Math.abs(distanceX), cameraSpeed);
const movementY = Math.sign(distanceY) * Math.min(Math.abs(distanceY), cameraSpeed);

// Update the camera position
app.stage.x += movementX;
app.stage.y += movementY;

// Return if the camera has reached the target position
if (app.stage.x === targetX && app.stage.y === targetY) {


      setEnemiesInRange(0);
      setCharAttackAnimating(false);
      setIsCharAttacking(false);
      app.stage.removeChild(frogGhostPlayer);
      critter.position.set(app.screen.width / 20, stored);
      setPlayerCurrentHealth(getPlayerHealth());
      updatePlayerHealthBar(getPlayerHealth() / getPlayerHealth() * 100);
      // Reset castle health
      castleHealth = 100;
      // Remove any existing enemy death sprites
      // Set isCombat and playAgain to false
      isCombat = false;
      const enemyPortrait = document.getElementById('enemy-portrait');
      enemyPortrait.style.display = 'none'; // Make the element visible
      playAgain = false;
      setIsDead(false);
      critter.loop = true;
      critter.textures = frogWalkTextures;
      critter.play();
      app.stage.addChild(critter);

      // Loop through the enemies array and remove each enemy
      for (let i = 0; i < getEnemies().length; i++) {
        let enemy = getEnemies()[i];
        // console.log(i);
        app.stage.removeChild(enemy);
        app.stage.removeChild(enemy.hpBar);
        app.stage.removeChild(enemy.hpBarBackground);
        // Destroy the enemy object to free up memory

      }

      // Clear the enemies array
      enemies.length = 0;
     setRoundOver(false);
  return;
}
return;
}


        if (getCharSwap()) {
          console.log("getcurrentchat", getCurrentCharacter());
          if (getCurrentCharacter() === "character-puffer") {
            playerSpawn.tint = 0x0000ff; // Blue
            playerSpawn.blendMode = PIXI.BLEND_MODES.ADD;
            playSpawnAnimation(critter,playerSpawn);
            frogWalkTextures = pufferWalkTextures;
            frogIdleTextures = pufferWalkTextures;
            frogAttackTextures = pufferAttackTextures;
          }
          else if (getCurrentCharacter() === "character-frog") {
            console.log("SWAP TO SNELL");
            playerSpawn.blendMode = PIXI.BLEND_MODES.ADD;
            playerSpawn.tint = 0x00ff80; // Light green

            playSpawnAnimation(critter,playerSpawn);
            frogWalkTextures = frogWalkTextures1;
            frogIdleTextures = frogIdleTextures1;
            frogAttackTextures = frogAttackTextures1;
          }
          else if (getCurrentCharacter() === "character-snail") {
            playerSpawn.blendMode = PIXI.BLEND_MODES.ADD;
            playerSpawn.tint = 0x800080; // Dark purple
            playSpawnAnimation(critter,playerSpawn);
            frogWalkTextures = snailWalkTextures;
            frogIdleTextures = snailWalkTextures;
            frogAttackTextures = snailAttackTextures;

          }
          else if (getCurrentCharacter() === "character-bee") {
            playerSpawn.tint = 0xffff00; // Yellow
 
playerSpawn.blendMode = PIXI.BLEND_MODES.ADD;
            playSpawnAnimation(critter,playerSpawn);
            frogWalkTextures = beeWalkTextures;
            frogIdleTextures = beeWalkTextures;
            frogAttackTextures = beeAttackTextures;

          }
          critter.position.x -= 20;
          setCharSwap(false);
          return;
        }

        if (getSpeedChanged()) { updateVelocity(); setSpeedChanged(false); }




        if (!isAttackingChar) {
          if (!getisDead()) {
            if (!isCombat) {
              if (!isPointerDown) {
                if (getEnemiesInRange() === 0) {


                  if (getCurrentCharacter() != "character-snail") {
                    critter.position.x += velocity.x;
                  }
                  else {
                    if (critter.currentFrame > critter.totalFrames / 2) {
                      critter.position.x += velocity.x + 1;
                    }
                  }
                  if ((critter.textures != frogWalkTextures)) {

                    critter.textures = frogWalkTextures;
                    critter.play();
                    critter.loop = true;




                  }
                  mountain1.position.x -= velocity.x * mountain1Speed;
                  mountain2.position.x -= velocity.x * mountain2Speed;
                }
                else {

                  // console.log("enemies in range");
                  if (critter.textures != frogIdleTexture) {
                    critter.textures = frogIdleTextures;
                    critter.stop();
                  }

                }
              }
              // Update background position for parallax effect
              // background.position.x = -critter.position.x * parallaxRatio;
              // background.position.y = -critter.position.y * 0.2;

            }
            else {

              if (critter.textures != frogIdleTexture) {
                critter.textures = frogIdleTextures;
                critter.stop();
              }
              critter.loop = false;
            }
          }







          if (critter.position.x > maxX - 100) {
            critter.position.x = maxX - 100;
          }
          if (critter.position.x > 1500) {
            hpBar.visible = true; // Show the HP bar
            hpBarBackground.visible = true;
          } else {
            hpBar.visible = false;
            hpBarBackground.visible = false; // Hide the HP bar
          }

        }

        // Update cloud position
        clouds.position.x -= cloudSpeed;

        // Check if cloud has gone offscreen and move it to the right side
        if (clouds.x + clouds.width / 2 < -700) {
          clouds.x = app.screen.width + clouds.width / 2;
        }
        if (!getAreResetting()) {
          // Adjust app stage position
          app.stage.x = Math.min(0, Math.max(-foreground.width + app.screen.width, -critter.position.x + app.screen.width / 2));
          app.stage.y = Math.min(0, Math.max(-foreground.height + app.screen.height, -critter.position.y + app.screen.height / 2));
        }
        else { }
      });
      app.stage.removeChild(loadingSprite);


      // document.getElementById("infoboxs").style.visibility = "visible";
      document.getElementById("coffee-button").style.visibility = "visible";
      document.getElementById("infoboxes").style.visibility = "visible";
      document.getElementById("ui-overlay").style.visibility = "visible";
      document.getElementById("pause-button").style.visibility = "visible";
      document.getElementById("coffee-button").style.visibility = "visible";
      critter.scale.set(getFrogSize());

      stored = app.screen.height - foreground.height / 2.2 - critter.height * .22;
      console.log("STORED", stored);
      critter.position.set(app.screen.width / 20, app.screen.height - foreground.height / 2.2 - critter.height * .22);
      updateEXP(0, expToLevel);
      updatePlayerHealthBar(getFrogHealth());
      app.stage.addChild(background, mountain1, mountain2, foreground, castle, critter, clouds, hpBarBackground, hpBar);
      spawnEnemy(critter, critterAttackTextures, frogAttackTextures, enemyDeath, critterWalkTextures, snailAttackTextures, foreground, frogIdleTextures, snailIdleTextures, frogGhostTextures, critterWalkTextures, frogGhostPlayer, frogWalkTextures, background, snailWalkTextures);
      setInterval(() => {
        if (!getisDead() && !getisPaused()) { spawnEnemy(critter, critterAttackTextures, frogAttackTextures, enemyDeath, critterWalkTextures, snailAttackTextures, foreground, frogIdleTextures, snailIdleTextures, frogGhostTextures, critterWalkTextures, frogGhostPlayer, frogWalkTextures, background, snailWalkTextures); }
      }, 12000);

    }

  }
  //frogPortrait.on('pointertap', handleFrogSpawn);






  function spawnEnemy(critter, critterAttackTextures, frogAttackTextures, enemyDeath, critterWalkTextures, snailAttackTextures, foreground, frogIdleTextures, snailIdleTextures, frogGhostTextures, critterWalkTextures, frogGhostPlayer, frogWalkTextures, background, snailWalkTextures) {
    let enemyAdded = false;
    const enemy = new PIXI.AnimatedSprite(critterWalkTextures); // Start with idle textures
    const minScale = 0.4;
    const maxScale = 0.6;
    const randomScale = minScale + Math.random() * (maxScale - minScale);
    const randomSpeedFactor = 0.75 + Math.random() * 0.5; // Random speed factor between 0.75 and 1.25
    // console.log("randomScale:", randomScale);
    enemy.scale.set(randomScale);
    enemy.anchor.set(0.5, .5);
    enemy.position.set(foreground.width, app.screen.height - 80 - randomScale * 120 + (Math.random() * 60 - 30));

    enemy.zIndex = enemy.position.y + 10000;
    // console.log("ZINEX:", -enemy.position.y);
    //console.log("enemy.zIndex:", enemy.zIndex);

    enemy.animationSpeed = 0.25;
    enemy.loop = true;
    enemy.isAlive = true;
    enemy.isVisible;
    enemy.currentHP = 100;
    enemy.play();
    enemy.scale.x *= -1; // Flip the enemy horizontally
    enemy.vx = -2 * randomSpeedFactor; // Set the enemy's horizontal velocity with random speed factor
    let isAttacking = false; // Flag to track if enemy is attacking

    // Add enemy to the enemies array
    addEnemies(enemy);
    if (enemy.isAlive) {
      app.stage.addChild(enemy);
    }
    if (app.stage.children.includes(enemy)) {
      enemies.sort((a, b) => a.position.y - b.position.y);
      enemies.forEach((enemy) => {
        if (enemy.parent === app.stage) {
          app.stage.removeChild(enemy);
        }
      });
      enemies.forEach((enemy) => {
        app.stage.addChild(enemy);
      });
    }
    let runOnce = 0;

    app.ticker.add(() => {
      if (getisPaused() || getRoundOver()) {
        // Game is paused, skip logic
        return;
      }
      

      if (app.stage.children.includes(enemy)) {

        if (enemy.isAlive && (enemy.position.x - critter.position.x > 150) || getisDead()) {

          if (enemy.visible && enemy.textures !== critterWalkTextures) {
            // enemy.textures = critterWalkTextures;
            enemy.play();
          }
          enemy.position.x += enemy.vx;
        } else {
          if ((critter.textures !== frogWalkTextures) && (critter.textures !== snailWalkTextures)) {
            if (critter.currentFrame === critter.totalFrames - 2) {
              if (!getIsCharAttacking()) {
                setIsCharAttacking(true);
                critterAttack(critter, enemy, enemiesInRange, enemyDeath, critterAttackTextures);
              }
            } else if (critter.currentFrame === critter.totalFrames - 1) {
              setIsCharAttacking(false);
            }
          }
          if (!enemyAdded) {
            setEnemiesInRange(getEnemiesInRange() + 1);
            enemyAdded = true;
          }
          if (!getisDead() && !isAttacking && enemy.isAlive && enemy.visible) {
            if (!isCombat) {
              const enemyPortrait = document.getElementById('enemy-portrait');
              updateEnemyGrayscale(100);
              enemyPortrait.style.display = 'block'; // Make the element visible
            }
            isAttacking = true;
            isCombat = true;
            handleEnemyAttacking(enemy, critterAttackTextures, critter, frogAttackTextures, enemyDeath, snailAttackTextures, frogIdleTextures, snailIdleTextures, frogGhostTextures, critterWalkTextures, frogGhostPlayer, frogWalkTextures, background);
            if (enemy.isAlive && !getisDead()) {
              //console.log("here");
              drawEnemyHPBar(enemy);
            }
          }
        }
      } else {
        app.stage.removeChild(enemy);
        if (enemy.hpBarBackground && enemy.hpBar) {
          app.stage.removeChild(enemy.hpBarBackground);
          app.stage.removeChild(enemy.hpBar);
        }
        // Remove the enemy object from the enemies array
        const index = getEnemies().indexOf(enemy);
        if (index !== -1) {
          getEnemies().splice(index, 1);
        }
        app.ticker.remove(() => { });
        return;
      }
    });

    if (app.stage.children.includes(enemy)) {
      enemies.sort((a, b) => a.position.y - b.position.y);
      enemies.forEach((enemy) => {
        if (enemy.parent === app.stage) {
          app.stage.removeChild(enemy);
          app.stage.addChild(enemy);
        }
      });
    }


  }

  let isPlayerAttacking = false;

  function onPlayerAttack() {
    isPlayerAttacking = true;
  }


  function playGhostFly(critter, enemy, frogGhostPlayer, frogWalkTextures, background) {
    setIsDead(true);
    frogGhostPlayer.alpha = 0.5;

    var currentCharacter = getCurrentCharacter();

    switch (currentCharacter) {
      case "character-snail":
        frogGhostPlayer.texture = PIXI.Texture.from("frog_snail");
        break;
      case "character-bee":
        frogGhostPlayer.texture = PIXI.Texture.from("frog_bee");
        break;
      case "character-puffer":
        frogGhostPlayer.texture = PIXI.Texture.from("frog_puffer");
        break;

      default:
        // Use a default texture if the character is not recognized
        frogGhostPlayer.texture = PIXI.Texture.from("frog_ghost");
        break;
    }

    app.stage.addChild(frogGhostPlayer);

    let startY = frogGhostPlayer.y; // starting position
    let targetY = startY - 400; // target position
    let speed = 1.5; // speed of the movement
    let wobbleSpeed = 0.05; // speed of the wobble
    let wobbleAmplitude = 7.5; // initial amplitude of the wobble
    let wobbleDamping = 0.99; // damping factor of the wobble

    let moveInterval = setInterval(() => {
      frogGhostPlayer.y -= speed;
      let wobbleOffset = Math.sin(frogGhostPlayer.y * wobbleSpeed) * wobbleAmplitude;
      frogGhostPlayer.x += wobbleOffset;
      wobbleAmplitude *= wobbleDamping;
      if (frogGhostPlayer.y <= targetY) {
        frogGhostPlayer.y = targetY; // Ensure the frog reaches the exact target position
        resetGame(critter, enemy, frogGhostPlayer, enemies, frogWalkTextures, background);
        clearInterval(moveInterval);
      }
    }, 16); // (16ms = 60fps)
  }


  const screenWidth = window.innerWidth;
  const screenHeight = window.innerHeight;
  const spawnCircleRadius = Math.sqrt(screenWidth * screenWidth + screenHeight * screenHeight);
  let shrinkSpeed = 0.02;


  function handleEnemyAttacking(enemy, critterAttackTextures, critter, frogAttackTextures, enemyDeath, snailAttackTextures, frogIdleTextures, snailIdleTextures, frogGhostTextures, critterWalkTextures, frogGhostPlayer, frogWalkTextures, background) {
    enemy.textures = critterAttackTextures;
    enemy.loop = true;
    enemy.gotoAndPlay(0);
    let hasDied = false;
    let hasPlayedSound = false;

    function onFrameChange(currentFrame) {
if(getRoundOver() || getisPaused()){return;}
      if (currentFrame === enemy.totalFrames - 5) {

        if (enemy.isAlive) {
          if (!getisDead()) {
            if (!hasDied) {
              critter.tint = flashColor;
              setPlayerCurrentHealth(getPlayerCurrentHealth() - 5);
              updatePlayerHealthBar((getPlayerCurrentHealth() / getPlayerHealth()) * 100);
            }
            updatePlayerHealthBar((getPlayerCurrentHealth() / getPlayerHealth() * 100));
            if (getPlayerCurrentHealth() <= 0) {
              setPlayerCurrentHealth(0);

              if (enemy.textures != critterWalkTextures) {
                enemy.textures = critterWalkTextures;
                // console.log("ohhey");
                enemy.gotoAndPlay(0);
              }
              if (!hasDied) {
                // console.log("playerhp", playerHP);
                hasDied = true;
                frogGhostPlayer.position.set(critter.position.x, critter.position.y);
                critter.tint = 0xffffff;
                app.stage.removeChild(critter);
                for (let i = 0; i < enemies.length; i++) {
                  const enemy = enemies[i];

                  if (app.stage.children.includes(enemy.hpBarBackground)) {
                    app.stage.removeChild(enemy.hpBarBackground);
                  }

                  if (app.stage.children.includes(enemy.hpBar)) {
                    app.stage.removeChild(enemy.hpBar);
                  }
                }
                playGhostFly(critter, enemy, frogGhostPlayer, frogWalkTextures, background);
                enemy.textures = critterWalkTextures;
                enemy.play();
              }
              return;
            }
            setTimeout(() => {
              critter.tint = getFrogTintColor();
            }, flashDuration);
            if (enemy.isAlive) {
              hitSound.volume = .1;
              hitSound.play();
            }
            hasPlayedSound = true;
          }
          else{if(enemy.textures != critterWalkTextures){enemy.textures = critterWalkTextures;enemy.play();} }

        }
        else { console.log("enemy is dead"); }

      }
    }

    enemy.onFrameChange = onFrameChange;

    let hasAttackedCritter = false;
    let isAttackTriggered = false;
    const tickerHandler = () => {
      if (enemy.currentFrame === 0) {
        hasPlayedSound = false;
        if (enemy.position.x - critter.position.x < 150) {
          if (getEnemies().length === 0) {
            const enemyPortrait = document.getElementById('enemy-portrait');
            enemyPortrait.style.display = 'none'; // Make the element visible
            isCombat = false;
          } else {
            // Additional logic for enemy attacks
          }
        }
      }
    };

    app.ticker.add(tickerHandler);

    const removeEnemy = () => {
      if (app.stage.children.includes(enemy)) {
        app.stage.removeChild(enemy);
        app.stage.removeChild(enemy.hpBar);
        app.stage.removeChild(enemy.hpBarBackground);
      }

      const index = getEnemies().indexOf(enemy);
      if (index !== -1) {
        getEnemies().splice(index, 1);
      }

      app.ticker.remove(tickerHandler);
      enemy.onFrameChange = null; // Remove the onFrameChange event listener
    };

    app.ticker.add(() => {
      if (!app.stage.children.includes(enemy)) {
        removeEnemy();
      }
    });
  }


  function resetGame(critter, enemy, frogGhostPlayer, enemies, frogWalkTextures, background) {
    let isReset = false;
    //  console.log(getEnemies());

    if (!isReset) {
      setEnemiesInRange(0);
      setCharAttackAnimating(false);
      setIsCharAttacking(false);
      app.stage.removeChild(frogGhostPlayer);
      background.position.set(0, 0); // Adjust the position as needed
      //console.log("STORED", stored);
      critter.position.set(app.screen.width / 20, stored);
      setPlayerCurrentHealth(getPlayerHealth());
      updatePlayerHealthBar(getPlayerHealth() / getPlayerHealth() * 100);
      // Reset castle health
      castleHealth = 100;

      // Remove any existing enemy death sprites
      // Set isCombat and playAgain to false
      isCombat = false;
      const enemyPortrait = document.getElementById('enemy-portrait');
      enemyPortrait.style.display = 'none'; // Make the element visible
      playAgain = false;
      setIsDead(false);
      critter.loop = true;
      critter.textures = frogWalkTextures;
      critter.play();
      app.stage.addChild(critter);

      // Loop through the enemies array and remove each enemy
      for (let i = 0; i < getEnemies().length; i++) {
        let enemy = getEnemies()[i];
        // console.log(i);
        app.stage.removeChild(enemy);
        app.stage.removeChild(enemy.hpBar);
        app.stage.removeChild(enemy.hpBarBackground);
        // Destroy the enemy object to free up memory

      }

      // Clear the enemies array
      enemies.length = 0;
    }
  }


  function getCharacterDamage(currentCharacter) {
    switch (currentCharacter) {
      case 'character-snail':
        return getSnailDamage();
        break;
      case 'character-puffer':
        return getPufferDamage();
        break;
      case 'character-frog':
        return getFrogDamage();
        break;
      case 'character-bee':
        return getBeeDamage();
        break;
      default:
        console.log('Invalid character', currentCharacter);
    }
  }


  function drawHitSplat(enemy) {

    // Flash hit color for a brief second
    const originalTint = enemy.tint;
    enemy.tint = 0xFF0000; // Set the hit color
    setTimeout(() => {
      enemy.tint = originalTint; // Reset to original color
    }, 100);
    let damage = null;


    switch (getCurrentCharacter()) {
      case 'character-snail':
        console.log('Snail damage: ', getSnailDamage());
        enemy.currentHP -= getSnailDamage();
        damage = -getSnailDamage(); // Assuming getFrogDamage() returns a positive value
        break;
      case 'character-puffer':
        enemy.currentHP -= getPufferDamage();
        damage = -getPufferDamage(); // Assuming getFrogDamage() returns a positive value
        break;
      case 'character-frog':
        enemy.currentHP -= getFrogDamage();
        damage = -getFrogDamage(); // Assuming getFrogDamage() returns a positive value
        break;
      case 'character-bee':
        enemy.currentHP -= getBeeDamage();
        damage = -getBeeDamage(); // Assuming getFrogDamage() returns a positive value
        break;
      default:
        console.log('Invalid character type');
    }
    drawEnemyHPBar(enemy);
    updateEnemyGrayscale(enemy.currentHP);


    const damageText = new PIXI.Text(`${damage}`, {
      fontFamily: 'Marker Felt Cursive',
      fontSize: 24,
      fill: 'red',
      dropShadow: true,
      dropShadowColor: 'black',
      dropShadowBlur: 4,
      dropShadowAngle: Math.PI / 4,
      dropShadowDistance: 2,
    });

    damageText.anchor.set(0.5);
    damageText.position.set(enemy.position.x + 40, enemy.position.y - enemy.height / 1.3);
    app.stage.addChild(damageText);

    // Animate the hitsplat
    const startY = damageText.position.y; // Adjust the starting Y position as needed
    const duration = 100; // Animation duration in milliseconds
    let elapsed = 0; // Elapsed time
    const update = (delta) => {
      elapsed += delta;

      if (elapsed >= duration) {
        app.ticker.remove(update); // Stop the ticker update
        app.stage.removeChild(damageText); // Remove hitsplat after animation
      } else {
        const progress = elapsed / duration;
        damageText.position.y = startY - (progress * 30); // Update the Y position based on progress
        damageText.alpha = 1 - progress; // Update the alpha (opacity) based on progress
      }
    };

    app.ticker.add(update); // Start the ticker update for hitsplat animation
  }



  let isCritterAttackTriggered = false;
  function critterAttack(critter, enemy, enemiesInRange, enemyDeath, critterAttackTextures) {
    // Reduce enemy's HP
    console.log('ENEMY HP', enemy.currentHP);
    console.log("dmgD", getCharacterDamage(getCurrentCharacter()));
    if (enemy.currentHP - getCharacterDamage(getCurrentCharacter()) <= 0) {
      // Callback function to remove enemy after death animation
      if (app.stage.children.includes(enemy)) {
        drawHitSplat(enemy);
        enemy.tint = 0xFF0000; // Set the hit color

        setEnemiesInRange(getEnemiesInRange() - 1);
        isCombat = false;
        if (getEnemiesInRange() === 0) {
          const enemyPortrait = document.getElementById('enemy-portrait');
          enemyPortrait.style.display = 'none'; // Make the element visible
        }

        setIsCharAttacking(false);
        console.log("ENEMY DEAD", enemy.position.x, enemy.position.y);
        createCoffeeDrop(enemy.position.x + 20, enemy.position.y);
        app.stage.removeChild(enemy);
        getEnemies().splice(getEnemies().indexOf(enemy), 1);

        playDeathAnimation(enemy, enemyDeath, critter);
      }
    } else {
      if (enemy.isAlive === true) {
        if (getisDead() === false) {
          drawHitSplat(enemy);

        }
      }


    }


  }
  function createCoffeeDrop(x, y) {
    // Create a container to hold the coffee beans
    const coffeeContainer = new PIXI.Container();

    // Get the bean texture from the loaded resources
    const beanTexture = PIXI.Texture.from("https://i.imgur.com/Ft63zNi.png");

    // Generate a random number between 1 and 10 for the number of coffee beans
    const numBeans = Math.floor(Math.random() * 15) + 1;

    // Define the duration (in milliseconds) for the coffee beans to fall
    const duration = 2000; // Adjust this value as desired

    // Create and position coffee beans randomly within the container
    for (let i = 0; i < numBeans; i++) {
      const bean = new PIXI.Sprite(beanTexture);

      // Set the initial position of the coffee bean
      bean.anchor.set(0.5); // Set the anchor point to the center of the bean
      bean.x = x + Math.random() * 80 - 10; // Randomize the x position within a range
      bean.y = y + Math.random() * 60 - 20;;

      // Set a random rotation angle for the coffee bean
      bean.rotation = Math.random() * Math.PI * 2;

      // Set the scale of the coffee bean (adjust the values as desired)
      bean.scale.set(0.075 + Math.random() * 0.2); // Randomize the scale between 0.3 and 0.5

      // Add the coffee bean to the container
      coffeeContainer.addChild(bean);

      // Animate the coffee bean to drop gradually
      const targetY = y + 50; // Adjust the target position as desired
      const initialY = bean.y - 50;
      const startTime = Date.now();

      const update = () => {
        const elapsedTime = Date.now() - startTime;
        const progress = elapsedTime / duration;

        if (progress >= 1) {
          bean.y = targetY;
          return;
        }

        bean.y = initialY + (targetY - initialY) * progress;
        requestAnimationFrame(update);
      };

      update();
    }

    // Add the coffee container to the stage or another container in your application
    app.stage.addChild(coffeeContainer);

    // Start a timer to remove the coffee beans after the specified duration
    setTimeout(() => {
      // Remove the coffee container from the stage or parent container
      app.stage.removeChild(coffeeContainer);
    }, duration * 3);
    addCoffee(numBeans);
  }

  function addCoffee(amount) {
    setCoffee(getCoffee() + amount);
    const coffeeAmountElement = document.getElementById('coffee-amount');
    const coffeeAmount = getCoffee();
    coffeeAmountElement.textContent = `x ${coffeeAmount}`;
  }

function playSpawnAnimation(critter,critterSpawn)
{
critterSpawn.position.set(critter.position.x,critter.position.y);
app.stage.addChild(critterSpawn);


critterSpawn.gotoAndPlay(0);

    // Remove the death animation after it completes
      critterSpawn.onComplete = () => {
      app.stage.removeChild(critterSpawn);
    };



}


  function playDeathAnimation(enemy, enemyDeath, critter) {

    // Add the death animation sprite to the stage
    enemyDeath.position.set(enemy.position.x, enemy.position.y);
    app.stage.addChild(enemyDeath);
    const expDrop = new PIXI.Text("+15 EXP", {
      fontSize: 18,
      fill: "orange",
      fontWeight: "bold",
      stroke: "#000",
      strokeThickness: 3,
      strokeOutside: true
    });
    expDrop.position.set(enemy.position.x + 20, enemy.position.y - 20);
    expDrop.zIndex = 9999999999;
    app.stage.addChild(expDrop);

    // Animate the EXP drop text
    const startY = enemy.position.y - 20;

    const endY = startY - 50; // Adjust the value to control the floating height
    const duration = 2600; // Animation duration in milliseconds
    const startTime = performance.now();

    const animateExpDrop = (currentTime) => {
      const elapsed = currentTime - startTime;

      if (elapsed < duration) {
        const progress = elapsed / duration;
        const newY = startY - (progress * (startY - endY));
        expDrop.position.y = newY;
        requestAnimationFrame(animateExpDrop);
      } else {
        // Animation complete, remove the EXP drop text
        app.stage.removeChild(expDrop);
      }
    };

    requestAnimationFrame(animateExpDrop);
    // Play the death animation
    enemyDeath.gotoAndPlay(0);

    // Remove the death animation after it completes
    enemyDeath.onComplete = () => {
      setPlayerEXP(getPlayerEXP() + 100);
      updateEXP(getPlayerEXP(), expToLevel, critter);

      // Create the EXP drop text


      // Remove the death animation sprite after it completes
      app.stage.removeChild(enemyDeath);
      //isCombat=false;
    };
  }



  function drawEnemyHPBar(enemy) {
    const hpBarWidth = enemy.width / 2;
    const hpBarHeight = 8;
    const hpBarX = (enemy.x - hpBarWidth / 2) + 25;
    const hpBarY = enemy.y - enemy.height / 2 - 10;

    // Remove previous HP bar graphics if they exist
    if (enemy.hpBarBackground && enemy.hpBar) {
      app.stage.removeChild(enemy.hpBarBackground);
      app.stage.removeChild(enemy.hpBar);
      enemy.hpBarBackground = null;
      enemy.hpBar = null;
    }

    if (!getisDead()) {
      // Create new HP bar graphics
      enemy.hpBarBackground = new PIXI.Graphics();
      enemy.hpBarBackground.beginFill(0x000000);
      enemy.hpBarBackground.drawRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);
      enemy.hpBarBackground.endFill();
      app.stage.addChild(enemy.hpBarBackground);

      enemy.hpBar = new PIXI.Graphics();
      enemy.hpBar.beginFill(0xff0000);
      enemy.hpBar.drawRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);
      enemy.hpBar.endFill();
      app.stage.addChild(enemy.hpBar);

      // Update the HP bar based on the enemy's health
      const maxHealth = 100; // Replace with actual max health of enemy
      const currentHealth = enemy.currentHP; // Replace with actual current health of enemy
      const hpBarRatio = enemy.currentHP / maxHealth;
      const hpBarWidthActual = hpBarWidth * hpBarRatio;
      enemy.hpBar.clear();
      enemy.hpBar.beginFill(0xff0000);
      enemy.hpBar.drawRect(hpBarX, hpBarY, hpBarWidthActual, hpBarHeight);
      enemy.hpBar.endFill();
    }
  }


  function handlePlayClick() {

    if (!isGameStarted) {
      isGameStarted = true;

      startGame();
    }
  }

  function handleSnailClick() {


    if (!isGameStarted) {
      isGameStarted = true;

      startGame();
    }
  }


  // Update the grayscale effect based on HP bar value



  function updatePlayerHealthBar(health) {
    const playerHealthBarFill = document.getElementById('health-bar-fill');
    playerHealthBarFill.style.width = health + '%';
    updateGrayscale(health);
    updateBarText('hp-text', 'hp', health);
  }


  function updateBarText(elementId, labelText, value) {
    const barText = document.getElementById(elementId);
    const roundedValue = getPlayerCurrentHealth().toFixed();
    barText.innerText = `${labelText}:\u00A0 ${roundedValue}\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\/${getPlayerHealth()}`;
  }

  function updateGrayscale(hpPercentage) {
    const grayscalePercentage = 100 - hpPercentage;
    document.getElementById('character-portrait').style.filter = `sepia(${grayscalePercentage}%)`;
  }

  function updateEnemyGrayscale(hpPercentage) {
    const grayscalePercentage = 100 - hpPercentage;
    document.getElementById('enemy-portrait').style.filter = `grayscale(${grayscalePercentage}%)`;
  }

  function updateEXP(exp, expToLevel1, critter) {
    let leftover = 0;
    if (exp >= expToLevel) {
      leftover = exp - expToLevel;
      setPlayerEXP(leftover);
      expToLevel = expToLevel1;
      expToLevel = expToLevel1 + expToLevel1 * .1;
      levelUp(critter);

    }
    const playerEXPBarFill = document.getElementById('exp-bar-fill');
    playerEXPBarFill.style.width = getPlayerEXP() / expToLevel * 100 + '%';
    updateExpText('exp-text', 'exp', getPlayerEXP(), expToLevel);
  }



  function updateExpText(elementId, labelText, value, expToLevel) {
    const barText = document.getElementById(elementId);
    const roundedEXPValue = Math.round(getPlayerEXP().toFixed());
    const roundedEnder = Math.round(expToLevel);
    barText.innerText = `${labelText}: ${roundedEXPValue}\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\/${roundedEnder}`;
  }

  let isUpgradeBoxesAnimated = false;

  function animateUpgradeBoxes(critter) {
    console.log("SLECT", getSelectLevel());
    if (isUpgradeBoxesAnimated) {
      return; // If already animated, exit the function
    }
    isUpgradeBoxesAnimated = true; // Set the flag to indicate animation has occurred
    const upgradeBoxes = document.querySelectorAll('.upgrade-box');
    upgradeBoxes.forEach((box) => {
      const classNames = box.classList;
      box.style.visibility = 'hidden'; // Hide all upgrade boxes initially

      if (
        classNames.contains('spd-upgrade') ||
        classNames.contains('hp-upgrade') ||
        classNames.contains('attack-upgrade')
      ) {
        box.style.visibility = 'visible'; // Make the first three upgrade boxes visible
      }

      box.style.animationPlayState = 'running';
      box.removeEventListener('click', box.clickHandler); // Remove previous event listener

      // Define the click event handler separately
      box.clickHandler = () => {
        const upgradeType = classNames[1];
        handleUpgrade(upgradeType, critter);
      };

      box.addEventListener('click', box.clickHandler); // Add the updated event listener
    });
  }



  let critterTint = 0;
  let currentLevel = 1;
  let currentAtkLevel = 1;
  let currentHpLevel = 1;


  // Define stats for each character
  let characterStats = {
    'character-frog': {
      speed: getFrogSpeed(),
      attack: getFrogDamage(),
      health: getFrogHealth(),
    },
    'character-snail': {
      speed: getSnailSpeed(),
      attack: getSnailDamage(),
      health: getSnailHealth(),
    },
    'character-puffer': {
      speed: getPufferSpeed(),
      attack: getPufferDamage(),
      health: getPufferHealth(),
    },
    'character-bee': {
      speed: getBeeSpeed(),
      attack: getBeeDamage(),
      health: getBeeHealth(),
    },
    // Add stats for other characters here
  };


  function setCharacterSpeed(currentCharacter, speed) {
    switch (currentCharacter) {
      case 'character-snail':
        setSnailSpeed(speed);
        break;
      case 'character-puffer':
        setPufferSpeed(speed);
        break;
      case 'character-frog':
        setFrogSpeed(speed);
        break;
      case 'character-bee':
        setBeeSpeed(speed);
        break;
      default:
        console.log('Invalid character', currentCharacter);
    }
  }

  function setCharacterHealth(currentCharacter, health) {
    switch (currentCharacter) {
      case 'character-snail':
        setSnailHealth(health);
        break;
      case 'character-puffer':
        setPufferHealth(health);
        break;
      case 'character-frog':
        setFrogHealth(health);
        break;
      case 'character-bee':
        setBeeHealth(health);
        break;
      default:
        console.log('Invalid character', currentCharacter);
    }
  }

  function setCharacterDamage(currentCharacter, attack) {
    switch (currentCharacter) {
      case 'character-snail':
        setSnailDamage(attack);
        break;
      case 'character-puffer':
        setPufferDamage(attack);
        break;
      case 'character-frog':
        setFrogDamage(attack);
        break;
      case 'character-bee':
        setBeeDamage(attack);
        break;
      default:
        console.log('Invalid character', currentCharacter);
    }
  }

  function setCharacterHealth(currentCharacter, hp) {
    switch (currentCharacter) {
      case 'character-snail':
        setSnailHealth(hp);
        break;
      case 'character-puffer':
        setPufferHealth(hp);
        break;
      case 'character-frog':
        setFrogHealth(hp);
        break;
      case 'character-bee':
        setBeeHealth(hp);
        break;
      default:
        console.log('Invalid character', currentCharacter);
    }
  }

  function getCharacterHealth(currentCharacter, hp) {
    switch (currentCharacter) {
      case 'character-snail':
        getSnailHealth();
        break;
      case 'character-puffer':
        getPufferHealth();
        break;
      case 'character-frog':
        getFrogHealth();
        break;
      case 'character-bee':
        getBeeHealth(hp);
        break;
      default:
        console.log('Invalid character', currentCharacter);
    }
  }



  function handleUpgrade(upgradeType, critter) {
    const upgradeBoxes = document.getElementsByClassName('upgrade-box');

    // Get the current character
    const currentCharacter = getCurrentCharacter();

    // Get the stats for the current character
    const stats = characterStats[currentCharacter];

    // Handle different upgrade types
    switch (upgradeType) {
      case 'spd-upgrade':
        // Logic for speed upgrade
        console.log('Speed upgrade');
        var divElement = document.getElementById("lightning-level");

        stats.level++;
        // Update the display
        stats.speed += 0.5; // Update the speed stat for the current character
        setCharacterSpeed(currentCharacter, stats.speed);
        //console.log(getCharacterSpeed(currentCharacter));
        setSpeedChanged(true);
        divElement.textContent = stats.speed.toString();

        setSelectLevel(getSelectLevel() - 1);

        break;

      case 'attack-upgrade':
        // Logic for attack upgrade
        console.log('Attack upgrade');
        var divElement = document.getElementById("swords-level");
        stats.attack++;
        stats.attack += 5; // Update the attack stat for the current character
        setCharacterDamage(currentCharacter, stats.attack);
        setSnailDamage(getSnailDamage() + 5);
        // Update the display with the new attack level
        divElement.textContent = stats.attack.toString();
        setSelectLevel(getSelectLevel() - 1);
        break;

      case 'hp-upgrade':
        // Logic for health upgrade
        console.log('Health upgrade');
        var divElement = document.getElementById("heart-level");
        stats.hp++;
        stats.health += 20; // Update the health stat for the current character
        setCharacterHealth(currentCharacter, stats.health);
        setPlayerCurrentHealth(getPlayerCurrentHealth() + 20);
        updatePlayerHealthBar(getPlayerCurrentHealth() / getPlayerHealth * 100);

        divElement.textContent = stats.health.toString();

        setSelectLevel(getSelectLevel() - 1);

        break;

      default:
        console.log('Invalid upgrade type', upgradeType);
    }
    chooseSound.play();

    if (getSelectLevel() <= 0) {
      for (let i = 0; i < upgradeBoxes.length; i++) {
        upgradeBoxes[i].style.visibility = 'hidden';
      }
    }

    isUpgradeBoxesAnimated = false;
  }





  function levelUp(critter) {
    const characterLevelElement = document.getElementById("character-level");

    // Function to update the character's level
    function updateCharacterLevel(level) {
      switch (getCurrentCharacter()) {
        case 'character-snail':
          level = snailLevel;
          break;
        case 'character-puffer':
          level = pufferLevel;
          break;
        case 'character-frog':
          level = frogLevel;
          break;
        case 'character-bee':
          level = beeLevel;
          break;
        default:
          console.log('Invalid character', getCurrentCharacter());
          return;
      }
      characterLevelElement.textContent = 'Lvl. ' + level;
    }

    // Determine which character is being leveled up
    switch (getCurrentCharacter()) {
      case 'character-snail':
        // Update level for character-snail
        updateCharacterLevel(snailLevel++);
        break;
      case 'character-puffer':
        // Update level for character-puffer
        updateCharacterLevel(pufferLevel++);
        break;
      case 'character-frog':
        // Update level for character-frog
        updateCharacterLevel(frogLevel++);
        break;
      case 'character-bee':
        // Update level for character-bee
        updateCharacterLevel(beeLevel++);
        break;
      default:
        console.log('Invalid character', critter);
        return;
    }

    setSelectLevel(getSelectLevel() + 1);
    animateUpgradeBoxes(critter);

    levelSound.play();
  }


  function updateTint(critter, percentage) {

  }

  playButton.on('mouseover', () => {
  playButton.scale.set(hoverScale);
  playButton.alpha = hoverAlpha;
});

playButton.on('mouseout', () => {
  playButton.scale.set(1);
  playButton.alpha = 1;
});
  playButton.on('pointertap', handlePlayClick);

  function handleVisibilityChange() {
  if (document.hidden || document.webkitHidden) {
    // Document is hidden, perform actions here (e.g., pause the game)
    setIsPaused(true);
  } else {
    // Document is visible again, perform actions here (e.g., resume the game)
    setIsPaused(false);
  }
}

// Add event listeners for visibility change
document.addEventListener("visibilitychange", handleVisibilityChange);
document.addEventListener("webkitvisibilitychange", handleVisibilityChange);

</script>
</body>

</html>