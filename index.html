<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Crittors</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.2.1/pixi.min.js"></script>


  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      min-height: 512px;
      height: 100vh;
    }

    #game-container {
      position: relative;
    }

    #ui-overlay {
      position: fixed;
      top: 0;
      left: 0;
      padding: 10px;
    }

    #health-bar {
      width: 200px;
      height: 20px;
      background-color: #ccc;
      border: 2px solid #000;
      position: relative;
    }

    #health-bar-fill {
      height: 100%;
      background-color: #f00;

    }

    #exp-bar {
      width: 200px;
      height: 20px;
      background-color: #ccc;
      border: 2px solid #000;
      position: relative;
      margin-top: 5px;
    }

    #exp-bar-fill {
      height: 100%;
      background-color: #dbb948;
      width: 3%;
      /* Set the initial width to 1% */
    }

    .bar-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-weight: bold;
    }
  </style>
</head>

<body>
  <div id="game-container">
    <div id="ui-overlay">
      <div id="health-bar">
        <div id="health-bar-fill"></div>
        <span class="bar-text">HP</span>
      </div>
      <div id="exp-bar">
        <div id="exp-bar-fill"></div>
        <span class="bar-text">EXP</span>
      </div>
    </div>
  </div>


  <script>
    const app = new PIXI.Application({
      width: window.innerWidth,
      height: Math.max(window.innerHeight),
      antialias: true,
      transparent: false,
      resolution: 1,
    });

    document.body.appendChild(app.view);
    let isDead = false;
    function getisDead() {
      return isDead;
    }

    function setIsDead(value) {
      isDead = value;
    }

    let enemiesInRange = 0;
    function getEnemiesInRange() {
      return enemiesInRange;
    }

    function setEnemiesInRange(value) {
      enemiesInRange = value;
    }


    let enemies = [];

    function getEnemies() {
      return enemies;
    }

    function addEnemies(enemy) {
      console.log("added an eneymy");
      return enemies.push(enemy);
    }

    function clearEnemies(value) {
      enemies = [];
    }





    let isGameStarted = false;
    let playerMaxHP = 100;
    let playerHP = playerMaxHP;
    let playerEXP = 0;
    const flashDuration = 100; // Adjust as needed (in milliseconds)
    const flashColor = 0xff5555; // Bright red color
    const attackSound = new Audio();
    attackSound.src = "./attacksound.wav";
    const hitSound = new Audio();
    hitSound.src = "./hurt.wav";
    let isCombat = false;
    let playAgain = false;
    const menuTexture = PIXI.Texture.from('https://i.imgur.com/YtBjxdf.png');
    const menuSprite = new PIXI.Sprite(menuTexture);
    menuSprite.anchor.set(0.5);

    // Set the size of the menuSprite to match the app.screen size
    menuSprite.width = app.screen.width;
    menuSprite.height = app.screen.height;

    // Position the menuSprite at the center of the screen
    menuSprite.position.set(app.screen.width / 2, app.screen.height / 2);

    // Add the menuSprite to the stage
    app.stage.addChild(menuSprite);

    document.body.appendChild(app.view);
    const startText = new PIXI.Text('Choose your character!', {
      fontSize: 24,
      fill: 'white',
      align: 'center',
    });

    startText.anchor.set(0.5);
    startText.position.set(app.screen.width / 2, app.screen.height / 2 + 100);
    app.stage.addChild(startText);


    const frogPortraitTexture = PIXI.Texture.from('https://i.imgur.com/yzzwAH6.png');
    const frogPortrait = new PIXI.Sprite(frogPortraitTexture);
    frogPortrait.interactive = true;
    frogPortrait.buttonMode = true;
    frogPortrait.position.set(440, 0);
    app.stage.addChild(frogPortrait);
    let isFrog = false;


    let isPointerDown = false;
    function getisPointerdown() {
      return isPointerDown;
    }

    function startGame() {
      // Remove menu elements
      app.stage.removeChild(menuSprite);
      app.stage.removeChild(startText);
      const sound = new Audio();
      sound.src = "./theme.ogg";

      sound.volume = .2;
      sound.play();

      // Game elements and logic 
      const castleMaxHealth = 100;
      let castleHealth = castleMaxHealth;
      const LEFT_ARROW_KEYCODE = 37;
      const RIGHT_ARROW_KEYCODE = 39;
      const UP_ARROW_KEYCODE = 38;
      const SPACEBAR_KEYCODE = 32;
      const DOWN_ARROW_KEYCODE = 40;
      const speed = 2;
      const mountainVelocityX = 0;
      const mountainVelocityY = 0.2;
      const mountainVelocity1 = new PIXI.Point(0.2, 0.2);
      const mountainVelocity2 = new PIXI.Point(0.05, 0.05);
      let keysPressed = 0;
      let hp = 100;
      const hpBarColor = 0xff0000;

      PIXI.Loader.shared.add([
        { name: 'background', url: 'https://i.imgur.com/tvoaqaY.png' },
        { name: 'frog_ghost', url: 'https://i.imgur.com/45E9OPW.png' },
        { name: 'foreground', url: 'https://i.imgur.com/yIjGEpm.png' },
        { name: 'critter', url: 'https://i.imgur.com/Fl29VZM.png' },
        { name: 'critter_walk', url: 'https://i.imgur.com/CLqwc9P.png' },
        { name: 'critter_attack', url: 'https://i.imgur.com/knXBNGy.png' },
        { name: 'snail_idle', url: 'https://i.imgur.com/gbZmBqc.png' },
        { name: 'snail_walk', url: 'https://i.imgur.com/OsyKwTi.png' },
        { name: 'snail_attack', url: 'https://i.imgur.com/AA1JGFE.png' },
        { name: 'frog', url: 'https://i.imgur.com/juol8Q6.png' },
        { name: 'frog_walk', url: 'https://i.imgur.com/sQDZVrY.png' },
        { name: 'frog_attack', url: 'https://i.imgur.com/2Nr5t05.png' },
        { name: 'enemy_death', url: 'https://i.imgur.com/UD2YJ4w.png' },
        { name: 'mountain1', url: 'https://i.imgur.com/FP1W0k6.png' },
        { name: 'mountain2', url: 'https://i.imgur.com/Y6IKYjW.png' },
        { name: 'castle', url: 'https://i.imgur.com/a8MEgLK.png' },
        { name: 'clouds', url: 'https://i.imgur.com/ggEcYj9.png' }
      ]).load(setup);
      // hpBar.visible = false; // Initially hide the HP bar


      function setup() {

        const texture = PIXI.Loader.shared.resources['background'].texture;
        const background = new PIXI.Sprite(texture);
        background.anchor.set(0, 0);
        background.position.set(0, 0); // Adjust the position as needed
        background.width = app.screen.width * 4.8;
        background.height = app.screen.height * 1.6;

        const characterPortraitTexture = PIXI.Texture.from('https://i.imgur.com/8y7Ehfw.png');
        const characterPortrait = new PIXI.Sprite(characterPortraitTexture);
        const frogGhost = PIXI.Texture.from('frog_ghost');

        const frogGhostTextures = PIXI.Loader.shared.resources['frog_ghost'].texture;
        const frogGhostPlayer = new PIXI.Sprite(frogGhostTextures);

        frogGhostPlayer.anchor.set(0, 0);
        frogGhostPlayer.scale.set(0.4);


        const containerHeight = document.getElementById('game-container').clientHeight;
        const containerWidth = document.getElementById('game-container').clientWidth;
        const foreground = new PIXI.Sprite(PIXI.Loader.shared.resources['foreground'].texture);
        foreground.width = PIXI.Loader.shared.resources['foreground'].texture.width;
        foreground.height = PIXI.Loader.shared.resources['foreground'].texture.height;
        // console.log(app.screen.width / window.innerWidth );
        foreground.anchor.set(0, 1);
        foreground.x = 0;

        //console.log(app.screen.height);
        foreground.y = Math.max(app.screen.height);
        const mountain1 = createMountainSprite('mountain1', -100, mountainVelocity1, foreground);
        const mountain2 = createMountainSprite('mountain2', app.screen.width * 0.35, mountainVelocity2, foreground); // Adjust the position as needed

        // Adjust the x position if needed
        foreground.x = 0;

        const castleTexture = PIXI.Texture.from('castle');
        const castle = new PIXI.Sprite(castleTexture);
        castle.anchor.set(1, 1); // Set the anchor point to the bottom right of the castle


        // Calculate the castle position based on the screen width and height
        castle.position.set(foreground.width - castle.width * 0.05, app.screen.height - castle.height * 0.15);



        const hpBarWidth = 180;
        const hpBarHeight = 16;

        const hpBarX = castle.position.x - castle.width / 1.1;
        // console.log(hpBarX);
        const hpBarY = app.screen.height - 40 - hpBarHeight - 210; // Adjusted position
        const hpBarBackgroundColor = 0x000000;
        const hpBar = new PIXI.Graphics();
        hpBar.beginFill(hpBarColor, 1); // Set the alpha value for transparency
        hpBar.drawRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);
        hpBar.endFill();
        const hpBarBackground = new PIXI.Graphics();
        const hpBarBorderColor = 0x000000; // Black color
        const hpBarBorderThickness = 4; // Adjust the thickness as desired
        hpBarBackground.lineStyle(hpBarBorderThickness, hpBarBorderColor);
        hpBarBackground.beginFill(hpBarBackgroundColor, 0.5); // Set the alpha value for transparency
        hpBarBackground.drawRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);
        hpBarBackground.endFill();
        hpBarBackground.beginFill(hpBarBackgroundColor, 1); // Set the alpha value for transparency
        hpBarBackground.drawRect(hpBarX + hpBarBorderThickness, hpBarY + hpBarBorderThickness, hpBarWidth - hpBarBorderThickness * 2, hpBarHeight - hpBarBorderThickness * 2);
        hpBarBackground.endFill();




        function createMountainSprite(resourceName, xPos, velocity, foreground) {
          const sprite = new PIXI.Sprite(PIXI.Loader.shared.resources[resourceName].texture);
          const scaleFactor = Math.max(app.screen.height * 0.5 / sprite.height, app.screen.width * 1.2 / sprite.width);
          sprite.scale.set(scaleFactor);
          sprite.anchor.set(0, 1);

          // Calculate the mountain sprite position based on the screen height and sprite height
          sprite.position.set(xPos, app.screen.height - (foreground.height * 0.275));

          sprite.zIndex = -1;
          sprite.velocity = velocity;
          return sprite;
        }



        const frogIdleTexture = PIXI.Loader.shared.resources['frog'].texture;
        const frogIdleTextures = [frogIdleTexture];
        const frogWalkTextures = createAnimationTextures('frog_walk', 10, 351);
        const frogAttackTextures = createAnimationTextures('frog_attack', 12, 351);
        const critterAttackTextures = createAnimationTextures('critter_attack', 13, 266);
        const critterIdleTexture = PIXI.Loader.shared.resources['critter'].texture;
        const snailIdleTextures = createAnimationTextures('snail_idle', 20, 459);
        const critterWalkTextures = createAnimationTextures('critter_walk', 12, 266);
        const snailWalkTextures = createAnimationTextures('snail_walk', 20, 459);
        const snailAttackTextures = createAnimationTextures('snail_attack', 24, 459);
        const cloudsTexture = PIXI.Loader.shared.resources['clouds'].texture;
        const backgroundImage = PIXI.Sprite.from('background');
        const clouds = createTilingSprite(cloudsTexture, backgroundImage.width * 3, 200);
        const enemyDeathTextures = createAnimationTextures('enemy_death', 8, 317);

        const enemyDeath = createAnimatedSprite(enemyDeathTextures);


        let characterTextures;

        characterTextures = frogWalkTextures;

        const critter = createAnimatedSprite(characterTextures);
        critter.interactive = true;
        const snail = createAnimatedSprite(snailIdleTextures);
        snail.anchor.set(0.5);
        snail.position.set(app.screen.width / 2, app.screen.height / 2);
        snail.play();

        critter.textures = frogWalkTextures;
        critter.loop = true;
        critter.play();


        enemyDeath.animationSpeed = 0.2;
        enemyDeath.loop = false;
        enemyDeath.anchor.set(0.5);
        enemyDeath.scale.set(0.35);

        const velocity = new PIXI.Point();
        const parallaxRatio = 0.5;
        const speed = 1.25;
        const pressedKeys = new Set();
        let xDir = 0;
        let yDir = 0;
        let isMoving = false;
        let isAttackingChar = false;

        function createAnimationTextures(resourceName, frameCount, frameHeight) {
          const textures = [];
          const textureWidth = PIXI.Loader.shared.resources[resourceName].texture.width / frameCount;

          for (let i = 0; i < frameCount; i++) {
            const rect = new PIXI.Rectangle(i * textureWidth, 0, textureWidth, frameHeight);
            const texture = new PIXI.Texture(PIXI.Loader.shared.resources[resourceName].texture, rect);
            textures.push(texture);
          }

          return textures;
        }


        function createAnimatedSprite(textures) {
          const sprite = new PIXI.AnimatedSprite(textures);
          sprite.scale.set(0.6);
          sprite.anchor.set(0, 0);
          sprite.position.set(app.screen.width / 3, app.screen.height - foreground.height / 1.6);
          sprite.animationSpeed = 0.25;
          sprite.zIndex = 1;
          sprite.loop = true;
          return sprite;
        }

        function createTilingSprite(texture, width, height) {
          const sprite = new PIXI.TilingSprite(texture, width, height);
          sprite.tileScale.set(0.4);
          sprite.tilePosition.y = 200;
          app.stage.addChild(sprite);
          return sprite;
        }




        // Constants
        const SPACEBAR_KEYCODE = 32;

        // Variables

        let touchStartX = 0;
        let touchEndX = 0;
        let isTouchActive = false;

        let pointerHoldInterval;


        app.stage.interactive = true;

        app.stage.on("pointerdown", handleTouchStart);
        app.stage.on("pointertap", handleTouchTap);
        app.stage.on("pointerup", handleTouchEnd);

        //ritter.on('pointertap', handleFrogSpawn);

        xDir = 1;
        updateVelocity();


        // Function to handle pointerdown event
        function handleTouchStart(event) {
          // Set the pointer state to down
          isPointerDown = true;

          // Start a timer to simulate continuous action
          pointerHoldInterval = setInterval(handleTouchHold, 10);
        }

        // Function to handle pointerhold action
        function handleTouchHold() {
          //console.log("touch hold",isAttackingChar);
          if (!isAttackingChar) {
            isAttackingChar = true;
            if (isFrog) {
              critter.textures = frogAttackTextures;
            } else {
              critter.textures = snailAttackTextures;
            }
            critter.loop = false;
            critter.onComplete = function () {
              attackSound.src = "./attacksound.wav";
              attackSound.play();
              // console.log(castle.position.x - 300);
              if (critter.position.x > castle.position.x - castle.width / 1.1) {
                console.log("takingDamage");
                castleTakeDamage(10); // Damage calculation
              }
              isAttackingChar = false;

              critter.textures = frogIdleTextures;

              critter.play();
            };
            critter.play();
          }
        }

        // Function to handle pointertap event
        function handleTouchTap(event) {
          // Trigger single tap action here
          // For example, you can call the handleSpacebarKeyDown function
          //handleSpacebarKeyDown();
        }

        // Function to handle pointerup event
        function handleTouchEnd(event) {
          // Clear the pointer hold interval
          clearInterval(pointerHoldInterval);

          // Set the pointer state to up
          isPointerDown = false;

          // Add your existing code here for handling touch end
          if (isAttackingChar) {
            isAttackingChar = false;
            isMoving = false;
            if (isFrog) {
              if (!isCombat) {
                critter.textures = frogWalkTextures;
                critter.loop = true;
                critter.play();
              }
              else {
                critter.textures = frogIdleTextures;

              }

            }
            if (isTouchActive) {
              ////handleSpacebarKeyDown();
            }
          }


          xDir = 1;
          //updateVelocity();

        }






        function updateVelocity() {
          velocity.x = xDir * speed;
          velocity.y = yDir * speed;
          // console.log(isMoving);
          if (isMoving) {
            mountainVelocity1.x = mountainVelocityX;
            mountainVelocity1.y = mountainVelocityY;
            mountainVelocity2.x = mountainVelocityX;
            mountainVelocity2.y = mountainVelocityY;
          }
        }

        // Function to update the HP bar based on the castle's health
        function updateHPBar(health, maxHealth) {

          const hpRatio = health / maxHealth;
          const newHpWidth = Math.max(0, hpBarWidth * hpRatio);
          hpBar.clear();
          hpBar.beginFill(hpBarColor);
          hpBar.drawRect(hpBarX, hpBarY, newHpWidth, hpBarHeight);
          hpBar.endFill();
        }


        // Damage function
        function castleTakeDamage(damage) {
          castleHealth -= damage;
          if (castleHealth < 0) {
            castleHealth = 0;
            castleExplode();
          }
          updateHPBar(castleHealth, castleMaxHealth);
        }

        function castleExplode() {

        }


        const maxX = foreground.width - critter.width / 2; // set maximum X position
        const minX = critter.width / 2; // set minimum X position
        const maxY = app.screen.height * 0.85; // set maximum Y position
        const minY = app.screen.height * 0.5; // set minimum Y position
        //const parallaxRatio = 0.2;
        const cloudSpeed = 1 / 3.5;
        const mountain1Speed = 0.2;
        const mountain2Speed = 0.05;
        //console.log(isFrog);
        app.ticker.add(() => {
          //console.log(critter.textures);


          if (!isAttackingChar) {
            if (!getisDead()) {
              if (!isCombat) {
                if (!isPointerDown) {
                  if (getEnemiesInRange() === 0) {

                    critter.position.x += velocity.x;
                    //critter.position.y += velocity.y;
                    // Update mountain positions
                    mountain1.position.x -= velocity.x * mountain1Speed;
                    mountain2.position.x -= velocity.x * mountain2Speed;
                  }
                  else {
                    // console.log("enemies in range");
                    if (!getisPointerdown()) {
                      critter.textures = frogIdleTextures;
                    }
                  }
                }
                // Update background position for parallax effect
                background.position.x = -critter.position.x * parallaxRatio;
                background.position.y = -critter.position.y * 0.2;

              }
            }




            if (critter.position.x > maxX - 100) {
              critter.position.x = maxX - 100;
            } else if (critter.position.x < minX) {
              critter.position.x = minX;
            }
            //console.log(critter.position.x);
            // Check character's X position
            if (critter.position.x > 1500) {
              hpBar.visible = true; // Show the HP bar
              hpBarBackground.visible = true;
            } else {
              hpBar.visible = false;
              hpBarBackground.visible = false; // Hide the HP bar
            }

          }

          // Update cloud position
          clouds.position.x -= cloudSpeed;

          // Check if cloud has gone offscreen and move it to the right side
          if (clouds.x + clouds.width / 2 < 0) {
            clouds.x = app.screen.width + clouds.width / 2;
          }

          // Adjust app stage position
          app.stage.x = Math.min(0, Math.max(-foreground.width + app.screen.width, -critter.position.x + app.screen.width / 2));
          app.stage.y = Math.min(0, Math.max(-foreground.height + app.screen.height, -critter.position.y + app.screen.height / 2));
        });

        critter.position.set(app.screen.width / 20, app.screen.height - foreground.height / 1.2);

        app.stage.addChild(background, mountain1, mountain2, foreground, castle, critter, clouds, hpBarBackground, hpBar);
        spawnEnemy(critter, critterAttackTextures, frogAttackTextures, enemyDeath, critterWalkTextures, snailAttackTextures, foreground, frogIdleTextures, snailIdleTextures, frogGhostTextures, critterWalkTextures, frogGhostPlayer, frogWalkTextures);
        setInterval(() => {
          if (!getisDead()) { spawnEnemy(critter, critterAttackTextures, frogAttackTextures, enemyDeath, critterWalkTextures, snailAttackTextures, foreground, frogIdleTextures, snailIdleTextures, frogGhostTextures, critterWalkTextures, frogGhostPlayer, frogWalkTextures); }
        }, 10000);

      }

    }
    //frogPortrait.on('pointertap', handleFrogSpawn);



    function spawnEnemy(critter, critterAttackTextures, frogAttackTextures, enemyDeath, critterWalkTextures, snailAttackTextures, foreground, frogIdleTextures, snailIdleTextures, frogGhostTextures, critterWalkTextures, frogGhostPlayer, frogWalkTextures) {
      let enemyAdded = false;
      const enemy = new PIXI.AnimatedSprite(critterWalkTextures); // Start with idle textures
      const minScale = 0.3;
      const maxScale = 0.7;
      const randomScale = minScale + Math.random() * (maxScale - minScale);

      enemy.scale.set(randomScale);
      enemy.anchor.set(0.5 + (randomScale - 0.5) * (1 - randomScale) * 2, 0.5);
      enemy.position.set(foreground.width, app.screen.height - foreground.height / 1.6 - (Math.random() * 120 - 60));
      enemy.zIndex = -enemy.position.y;
      enemy.animationSpeed = 0.25;
      enemy.loop = true;
      enemy.isAlive = true;
      enemy.isVisible;
      enemy.currentHP = 100;
      enemy.play();
      enemy.scale.x *= -1; // Flip the enemy horizontally
      enemy.vx = -2; // Set the enemy's horizontal velocity
      let isAttacking = false; // Flag to track if enemy is attacking
      let hasAttacked = false; // Flag to track if the enemy has attacked

      // Add enemy to the enemies array
      addEnemies(enemy);
      if (enemy.isAlive) {
        app.stage.addChild(enemy);
      }

      let runOnce = 0;
      app.ticker.add(() => {
        if (app.stage.children.includes(enemy)) {
          if (enemy.isAlive && (enemy.position && enemy.position.x - critter.position.x > 140) || getisDead()) {
            enemy.loop = true;
            if (enemy.textures !== critterWalkTextures) {
              enemy.textures = critterWalkTextures;
            }
            enemy.position.x += enemy.vx;
          } else {
            if (!enemyAdded) {
              setEnemiesInRange(getEnemiesInRange() + 1);

              if (!getisPointerdown() && !getisDead()) {
                critter.textures = frogIdleTextures;
              }
              enemyAdded = true;
            }

            if (!getisDead() && !isAttacking && enemy.isAlive && enemy.visible) {
              isAttacking = true;
              isCombat = true;
              handleEnemyAttacking(enemy, critterAttackTextures, critter, frogAttackTextures, enemyDeath, snailAttackTextures, frogIdleTextures, snailIdleTextures, frogGhostTextures, critterWalkTextures, frogGhostPlayer, frogWalkTextures);
              if (enemy.isAlive && !getisDead()) {
                console.log("here");
                drawEnemyHPBar(enemy);
              }
            } else if (!getisDead() && isAttacking && !hasAttacked && enemy.currentFrame === 0 && isPlayerAttacking && enemy.isAlive) {
              hasAttacked = true;
              critterAttack(critter, enemy, enemiesInRange, enemyDeath);
              isPlayerAttacking = false; // Reset player attack flag after calling critterAttack
            } else if (getisDead()) {
              if (enemy.visible) {
                if (enemy.textures !== critterWalkTextures) {
                  enemy.textures = critterWalkTextures;
                }
                enemy.loop = true;
              }
            }
          }
        } else {
          if (runOnce === 0) {
            runOnce = 1;
            console.log("MADE");
            app.stage.removeChild(enemy);
            if (enemy.hpBarBackground && enemy.hpBar) {
              app.stage.removeChild(enemy.hpBarBackground);
              app.stage.removeChild(enemy.hpBar);
            }

            // Remove the enemy object from the enemies array
            const index = getEnemies().indexOf(enemy);
            if (index !== -1) {
              getEnemies().splice(index, 1);
            }
            app.ticker.remove(() => { });
          }

          return;
        }
      });

    }


    let isPlayerAttacking = false; // Flag to track if the player is attacking

    // player attack event handler
    function onPlayerAttack() {
      // Perform player attack logic

      isPlayerAttacking = true;
    }



    function playGhostFly(critter, enemy, frogGhostPlayer, frogWalkTextures) {
      setIsDead(true);
      frogGhostPlayer.alpha = 0.5;
      app.stage.addChild(frogGhostPlayer);
      //console.log(app.stage.height);

      // Move the frogGhostPlayer upwards until off the top of the screen
      let targetY = app.stage.height; // Adjust the value to set the target position
      let speed = 1.5; // Adjust the value to change the speed of the movement
      let wobbleSpeed = 0.05; // Adjust the value to change the speed of the wobble
      let wobbleAmplitude = 7.5; // Adjust the value to change the initial amplitude of the wobble
      let wobbleDamping = 0.99; // Adjust the value to change the damping factor of the wobble

      let moveInterval = setInterval(() => {
        frogGhostPlayer.y -= speed;
        // console.log(frogGhostPlayer.y);

        // Calculate the wobble offset
        let wobbleOffset = Math.sin(frogGhostPlayer.y * wobbleSpeed) * wobbleAmplitude;

        // Apply the wobble effect to the x position
        frogGhostPlayer.x += wobbleOffset;

        // Reduce the amplitude of the wobble over time
        wobbleAmplitude *= wobbleDamping;

        if (frogGhostPlayer.y <= 200) {

          resetGame(critter, enemy, frogGhostPlayer, enemies, frogWalkTextures);
          clearInterval(moveInterval);
        }
      }, 16); // Adjust the interval delay as needed (16ms = 60fps)
    }



    function handleEnemyAttacking(enemy, critterAttackTextures, critter, frogAttackTextures, enemyDeath, snailAttackTextures, frogIdleTextures, snailIdleTextures, frogGhostTextures, critterWalkTextures, frogGhostPlayer, frogWalkTextures) {
      enemy.textures = critterAttackTextures;
      enemy.loop = true;
      enemy.gotoAndPlay(0);
      let hasDied = false;
      let hasPlayedSound = false;

      function onFrameChange(currentFrame) {
        if (currentFrame === enemy.totalFrames - 5) {
          if (enemy.isAlive) {
            if (!getisDead()) {
              if (!hasDied) {
                critter.tint = flashColor;
                playerHP -= 5;
              }
              updatePlayerHealthBar((playerHP / playerMaxHP) * 100);
              if (playerHP <= 0) {
                playerHP = 0;

                if (enemy.textures != critterWalkTextures) {
                  enemy.textures = critterWalkTextures;
                  console.log("ohhey");
                  enemy.gotoAndPlay(0);
                }
                if (!hasDied) {
                  console.log("playerhp", playerHP);
                  hasDied = true;
                  frogGhostPlayer.position.set(critter.position.x, critter.position.y);
                  critter.tint = 0xffffff;
                  app.stage.removeChild(critter);
                  app.stage.removeChild(enemy.hpBar);
                  app.stage.removeChild(enemy.hpBarBackground);
                  playGhostFly(critter, enemy, frogGhostPlayer, frogWalkTextures);
                }
                return;
              }
              setTimeout(() => {
                critter.tint = 0xffffff;
              }, flashDuration);
              if (enemy.isAlive) {
                hitSound.play();
              }
              hasPlayedSound = true;
            }
          }
        }
      }

      enemy.onFrameChange = onFrameChange;

      let hasAttackedCritter = false;

      const tickerHandler = () => {
        if (enemy.currentFrame === 0) {
          hasPlayedSound = false;
          if (enemy.position.x - critter.position.x < 150) {
            if (getEnemies().length === 0) {
              isCombat = false;
            } else {
              // Additional logic for enemy attacks
            }

            if (critter.textures === frogAttackTextures) {
              if (!hasAttackedCritter) {
                critterAttack(critter, enemy, enemiesInRange, enemyDeath);
                hasAttackedCritter = true;
              }
            } else if (critter.textures === snailAttackTextures) {
              if (!hasAttackedCritter) {
                critterAttack(critter, enemy, enemiesInRange, enemyDeath);
                hasAttackedCritter = true;
              }
            }
          }
        } else {
          hasAttackedCritter = false;
        }
      };

      app.ticker.add(tickerHandler);

      const removeEnemy = () => {
        if (app.stage.children.includes(enemy)) {
          app.stage.removeChild(enemy);
          app.stage.removeChild(enemy.hpBar);
          app.stage.removeChild(enemy.hpBarBackground);
        }

        const index = getEnemies().indexOf(enemy);
        if (index !== -1) {
          getEnemies().splice(index, 1);
        }

        app.ticker.remove(tickerHandler);
        enemy.onFrameChange = null; // Remove the onFrameChange event listener
      };

      app.ticker.add(() => {
        if (!app.stage.children.includes(enemy)) {
          removeEnemy();
        }
      });
    }


    function resetGame(critter, enemy, frogGhostPlayer, enemies, frogWalkTextures) {
      let isReset = false;
      console.log(getEnemies());

      if (!isReset) {
        setEnemiesInRange(0);

        app.stage.removeChild(frogGhostPlayer);
        critter.position.set(app.screen.width / 20, app.screen.height - 250);
        playerHP = 100;
        updatePlayerHealthBar(100);
        // Reset castle health
        castleHealth = 100;

        // Remove any existing enemy death sprites
        // Set isCombat and playAgain to false
        isCombat = false;
        playAgain = false;
        setIsDead(false);
        critter.loop = true;
        critter.textures = frogWalkTextures;
        critter.gotoAndPlay(0);
        app.stage.addChild(critter);

        // Loop through the enemies array and remove each enemy
        for (let i = 0; i < getEnemies().length; i++) {
          let enemy = getEnemies()[i];
          console.log(i);
          app.stage.removeChild(enemy);
          app.stage.removeChild(enemy.hpBar);
          app.stage.removeChild(enemy.hpBarBackground);
          // Destroy the enemy object to free up memory



        }

        // Clear the enemies array
        enemies.length = 0;
      }
    }


    function critterAttack(critter, enemy, enemiesInRange, enemyDeath) {
      // Reduce enemy's HP
      if (enemy.currentHP - 20 <= 0) {

        // Callback function to remove enemy after death animation
        if (app.stage.children.includes(enemy)) {
          setEnemiesInRange(getEnemiesInRange() - 1);


          isCombat = false;

          app.stage.removeChild(enemy);
          getEnemies().splice(getEnemies().indexOf(enemy), 1);


          playDeathAnimation(enemy, enemyDeath);
          app.stage.removeChild(enemy.hpBar);
          app.stage.removeChild(enemy.hpBarBackground);

        }
      } else {
        if (enemy.isAlive === true) {
          if (getisDead() === false) {
            enemy.currentHP -= 20;
            drawEnemyHPBar(enemy);
          }
          else {
            app.stage.removeChild(enemy.hpBarBackground);
            app.stage.removeChild(enemy.hpBar);
          }
        }
        //console.log(enemy.currentHP);
      }
    }



    function playDeathAnimation(enemy, enemyDeath) {
      // Add the death animation sprite to the stage
      enemyDeath.position.set(enemy.position.x, enemy.position.y);
      app.stage.addChild(enemyDeath);

      // Play the death animation
      enemyDeath.gotoAndPlay(0);

      // Remove the death animation after it completes
      enemyDeath.onComplete = () => {
        playerEXP +=10;
        updateEXP(playerEXP );

        console.log(enemiesInRange);
        app.stage.removeChild(enemyDeath);
        //isCombat=false;
      };


    }



    function drawEnemyHPBar(enemy) {
      const hpBarWidth = enemy.width / 2;
      const hpBarHeight = 8;
      const hpBarX = (enemy.x - hpBarWidth / 2) + 30;
      const hpBarY = enemy.y - enemy.height / 2 - 10;

      // Remove previous HP bar graphics if they exist
      if (enemy.hpBarBackground && enemy.hpBar) {
        app.stage.removeChild(enemy.hpBarBackground);
        app.stage.removeChild(enemy.hpBar);
        enemy.hpBarBackground = null;
        enemy.hpBar = null;
      }

      if (!getisDead()) {
        // Create new HP bar graphics
        enemy.hpBarBackground = new PIXI.Graphics();
        enemy.hpBarBackground.beginFill(0x000000);
        enemy.hpBarBackground.drawRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);
        enemy.hpBarBackground.endFill();
        app.stage.addChild(enemy.hpBarBackground);

        enemy.hpBar = new PIXI.Graphics();
        enemy.hpBar.beginFill(0xff0000);
        enemy.hpBar.drawRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);
        enemy.hpBar.endFill();
        app.stage.addChild(enemy.hpBar);

        // Update the HP bar based on the enemy's health
        const maxHealth = 100; // Replace with actual max health of enemy
        const currentHealth = enemy.currentHP; // Replace with actual current health of enemy
        const hpBarRatio = enemy.currentHP / maxHealth;
        const hpBarWidthActual = hpBarWidth * hpBarRatio;
        enemy.hpBar.clear();
        enemy.hpBar.beginFill(0xff0000);
        enemy.hpBar.drawRect(hpBarX, hpBarY, hpBarWidthActual, hpBarHeight);
        enemy.hpBar.endFill();
      }
    }




    function handleFrogClick() {
      isFrog = true;

      // critter.textures = frog;
      if (!isGameStarted) {
        isGameStarted = true;

        startGame();
      }
    }

    function handleSnailClick() {
      isFrog = false;

      // critter.textures = frog;
      if (!isGameStarted) {
        isGameStarted = true;

        startGame();
      }
    }

    // Update the health bar based on the current health value
    function updatePlayerHealthBar(health) {
      const playerHealthBarFill = document.getElementById('health-bar-fill');
      playerHealthBarFill.style.width = health + '%';
    }

    function updateEXP(exp) {
      const playerEXPBarFill = document.getElementById('exp-bar-fill');
      playerEXPBarFill.style.width = exp + '%';
    }



    frogPortrait.on('pointertap', handleFrogClick);

  </script>
</body>

</html>